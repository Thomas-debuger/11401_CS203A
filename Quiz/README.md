# Announcement   

### Quiz I — Introduction to C Programming and Data Structures   
  這份考試內容主要是考察 C 語言的記憶體管理基礎以及演算法複雜度的初步概念，內容包含：

  * **C 語言動態記憶體操作實作**：練習使用 `malloc` 配置記憶體 、`realloc` 調整陣列大小 以及 `free` 釋放資源 ，並掌握 `sizeof` 的正確用法。
  * **安全性程式碼審查（Code Review）**：辨識常見的記憶體錯誤，例如未檢查 `malloc` 是否回傳 NULL 、直接對原指標使用 `realloc` 導致失敗時發生記憶體洩漏（Memory Leak）等問題。
  * **安全開發實踐**：學習使用「暫存指標（Temporary Pointer）」來處理記憶體重新配置 ，並在釋放記憶體後將指標設為 `NULL` 以防止懸空指標（Dangling Pointer）產生的錯誤。
  * **時間複雜度分析（Big O Notation）**：
    * 辨別基礎操作的複雜度，如陣列隨機存取為 O(1)，循序搜尋與遍歷為 O(n)。
    * 理解複合操作的效率，例如執行 n 次二分搜尋的複雜度為 O(nlogn)。
    * 排序演算法（如氣泡排序）的效能理解 O(n^2)。
  * **演算法效率排序**：掌握各種複雜度從最快（最有效率）到最慢的增長順序：O(1) < O(\log n) < O(n) < O(n \log n) < O(n^2) < O(n^3) < O(n!)。
  * **學習反饋與討論**：探討學習資料結構時面臨的挑戰與解決方法。

### Quiz II — Array, Linked List, Stack and Queue**ue**   
  內容的重點在於**動態指標操作**與**基礎線性結構的定義**：
  
  * **指標遷移機制實作 (`MoveTo` 函數)**：
    * **邏輯核心**：實作如何將 `target` 節點從原位移除，並插入到 `destination` 節點之後 。這需要精確操作指標，而非簡單地交換數據（Data Swapping）。
    * **關鍵步驟**：必須先尋找 `target` 的前驅節點（prevTarget）以維持串列不斷裂，接著依序完成「斷開連結」與「重新連結」的步驟。
    * **變體討論**：分析雙向鏈結串列（Doubly Linked List）如何透過前向指標（Prior Pointer）讓此操作更具效率。
  * **基礎 ADT 運作原理**：
    * **Stack (堆疊)**：遵循 **LIFO** (後進先出) 。必須掌握 `push` (推入) 與 `pop` (彈出) 的頂端操作。
    * **Queue (佇列)**：遵循 **FIFO** (先進先出) 。包含從末端 `enqueue` (入列) 與從前端 `dequeue` (出列) 的機制。
  * **AI 學習策略**：練習如何利用 AI 工具探討資料結構在現實場景中的應用實例與實作策略。

### Quiz III — Hash Table   
  這份考試內容專注於**雜湊碰撞（Collision）的成因及其解決方案**：

  * **雜湊表核心術語**：
    * **負載因子 ($\alpha$)**：定義為 n/m（元素量/表大小）。高負載因子會增加衝突機率，導致效能下降。
    * **碰撞處理**：比較「開放定址法（Open Addressing，所有資料存於表中）」與「鏈結法（Separate Chaining，使用桶子儲存清單）」的差異。
  * **群聚效應（Clustering）分析**：
    * **一次群聚**：線性探測法容易產生連續填滿的區塊，嚴重影響搜尋效率。
    * **二次群聚**：當多個鍵值具有相同雜湊值時，會遵循相同的探測序列（雖不一定連續）。
  * **雜湊函數計算實務**：
    * **除法餘數法**：觀察到當 h(k) = k mod 10 時，所有末位數相同的鍵值（如 27, 37, 47）皆會發生碰撞。
    * **折疊法 (Folding Method)**：學習將長數字切段求和（如 1234 -> 12 + 34 = 46） 。實驗證明折疊法能打亂輸入模式，使資料分佈更均勻。

### Quiz IV — Tree, Heap and Graph   
  本次測驗進入**非線性結構的演算法與分類**：

  * **圖形搜尋演算法 (BFS)**：
    * **運作邏輯**：使用「佇列 (Queue)」並以「層序 (Level-by-level)」方式訪問節點。
    * **路徑推導**：針對給定圖形，能列舉出所有符合規範的走訪順序（例如：從 0 開始，先訪問鄰近的 1, 2, 3, 4，再訪問更深層的 5, 6, 7）。
  * **運算式樹 (Expression Tree)**：
    * **走訪應用**：利用「中序走訪 (Inorder Traversal)」還原算術表達式。
    * **數值評估**：能將還原後的式子（如 3 x 4 + 10/2 - 3）正確計算出結果（14）。
  * **二元樹的多樣性分類**：
    * **形狀限制**：如「完全二元樹 (Complete Binary Tree)」要求除了最後一層外皆填滿，且最後一層需靠左對齊。
    * **規則限制**：
      * **BST**：左子樹 < 根節點 < 右子樹。
      * **Heap (堆積)**：父節點必須大於或等於（Max Heap）子節點，常用於優先權佇列。
      * **平衡樹 (AVL/Red-Black)**：具備自平衡機制，保證操作時間複雜度為 O(nlogn)。

### **Quiz V — Tree / Heap / Graph**
  這份考試內容主要是考察**樹與圖的基本術語理解，以及樹結構轉換為二元樹的能力**，內容包含：

  * **樹（Tree）與圖（Graph）的核心術語辨識**：

    * **Tree 專用術語**：

      * **Root node**：樹的起始節點，無父節點
      * **Parent / Child node**：節點的上下層關係
      * **Siblings**：具有相同父節點的節點
      * **Leaf node**：沒有子節點的節點
      * **Subtree**：以某節點為根所形成的子樹
      * **Degree**：節點所擁有的子節點數
      * **Height / Depth / Level**：描述節點在樹中位置與高度的指標
    * **Graph 專用術語**：

      * **Vertex (Node)**：圖中的節點
      * **Edge (Link)**：連接兩節點的邊
      * **Weighted Edge**：帶有權重（成本、距離）的邊

  * **一般樹（General Tree）轉換為二元樹（Binary Tree）**：

    * **轉換目的**：
      將「每個節點子節點數不固定」的一般樹，轉換為「每個節點最多兩個子節點」的二元樹表示法。
    * **核心方法：Left-Child Right-Sibling（左子右兄）表示法**

      * **First child → Left child**：
        每個節點的「第一個子節點」接到左子節點
      * **Next sibling → Right child**：
        每個節點的「下一個兄弟節點」接到右子節點
      * **移除其他原本的子節點連結**：
        僅保留「第一個子節點」與「下一個兄弟」的連結關係
    * **結果說明**：

      * 轉換後的結構是一棵合法的二元樹
      * 能完整保留原一般樹的階層與兄弟關係
      * 常用於將一般樹以二元樹形式儲存與處理

  * **學習重點與考試意義**：

    * 測試對**資料結構基本名詞的精準理解**
    * 驗證是否能將**概念性結構轉換為標準表示法**
    * 為後續 Binary Tree、Heap、AST 等應用打下基礎
