# P.19 Key-Value Pair

## 1ï¸âƒ£ å…ˆçœ‹é€™å€‹å¼å­åœ¨å¯«ä»€éº¼

```
<Value1, Value2>  â†’  Pair<Key, Value2>
```

æ„æ€æ˜¯ï¼š

* åŸæœ¬æœ‰ä¸€å°è³‡æ–™ **(Value1, Value2)** ç¶“éè™•ç†å¾Œï¼Œè®Šæˆ **(Key, Value2)**

## 2ï¸âƒ£ Value2 æ˜¯ä»€éº¼ï¼Ÿ

æŠ•å½±ç‰‡èªªï¼š

* **Value2 represents the important information**

ğŸ‘‰ **Value2 = æˆ‘å€‘çœŸæ­£æƒ³å­˜ã€æƒ³æŸ¥çš„è³‡æ–™**

ä¾‹å­ï¼š

* å­¸ç”Ÿæˆç¸¾
* å•†å“è³‡è¨Š
* ä½¿ç”¨è€…è³‡æ–™

## 3ï¸âƒ£ Value1 æ˜¯ä»€éº¼ï¼Ÿ

æŠ•å½±ç‰‡èªªï¼š

* **Value1 provides the source to derive or compute the key**

ğŸ‘‰ **Value1 ä¸æ˜¯ç›´æ¥æ‹¿ä¾†å­˜**
ğŸ‘‰ å®ƒæ˜¯ã€Œç”¨ä¾†ç”¢ç”Ÿ key çš„åŸæ–™ã€

ä¹Ÿå°±æ˜¯ï¼š

```
Key = f(Value1)
```

## 4ï¸âƒ£ ç”¨è¶…å¯¦éš›çš„ä¾‹å­ä¾†çœ‹

### ğŸ“ å­¸ç”Ÿè³‡æ–™ä¾‹å­

åŸå§‹è³‡æ–™ï¼š

```
<Value1, Value2>
<StudentID, StudentRecord>
```

è½‰æˆ Dictionary å½¢å¼ï¼š

```
Key = StudentID
Value = StudentRecord
```

æœ€å¾Œå­˜æˆï¼š

```
Pair<Key, Value2>
<StudentID, StudentRecord>
```

ğŸ“Œ StudentID æœ¬èº«å°±æ˜¯ key
ğŸ“Œ StudentRecord æ‰æ˜¯ä½ è¦æŸ¥çš„è³‡æ–™

### ğŸ“§ Email ç³»çµ±ä¾‹å­

åŸå§‹è³‡æ–™ï¼š

```
<Value1, Value2>
<EmailAddress, UserProfile>
```

Key ä¾†è‡ªï¼š

```
Key = hash(EmailAddress)
```

Dictionary è£¡å­˜ï¼š

```
<hash(EmailAddress), UserProfile>
```

ğŸ‘‰ Value1ï¼ˆEmailï¼‰ç”¨ä¾†ç®— key
ğŸ‘‰ Value2ï¼ˆUserProfileï¼‰æ˜¯é‡è¦è³‡æ–™

## 5ï¸âƒ£ ç‚ºä»€éº¼è¦é€™æ¨£åˆ†ï¼Ÿ

å› ç‚ºåœ¨ **Dictionary / Hash Table** è£¡ï¼š

* æŸ¥æ‰¾æ˜¯é  **key**
* è³‡æ–™æ˜¯å­˜åœ¨ **value**

æ‰€ä»¥è¨­è¨ˆæ™‚æœƒï¼š

1. ç”¨ Value1 ç”¢ç”Ÿ keyï¼ˆæ–¹ä¾¿ã€å¿«é€Ÿï¼‰
2. ç”¨ key æ‰¾åˆ° Value2ï¼ˆçœŸæ­£çš„è³‡æ–™ï¼‰

## 6ï¸âƒ£ ä¸€å¥è©±è€ƒè©¦ç‰ˆç¸½çµ 

* Dictionary ä¸­å­˜çš„æ˜¯ **(Key, Value)**
* **Value2** æ˜¯å¯¦éš›è¦å­˜å–çš„è³‡æ–™
* **Value1** ç”¨ä¾†ç”¢ç”Ÿæˆ–è¨ˆç®— key

æˆ–æ›´çŸ­ä¸€é»ï¼š

* **Key ä¾†è‡ª Value1ï¼Œè³‡æ–™å­˜åœ¨ Value2**

---

# p.20 Hashing

## 1ï¸âƒ£ ä»€éº¼æ˜¯ Hashingï¼Ÿ

* **Hashing æ˜¯ç”¨ä¸€å€‹æ•¸å­¸å‡½æ•¸ï¼ŒæŠŠ key ç›´æ¥ç®—æˆé™£åˆ—ä½ç½®ï¼Œè®“ä½ ä¸ç”¨ä¸€å€‹ä¸€å€‹æ‰¾è³‡æ–™ã€‚**

## 2ï¸âƒ£ Hash Table åœ¨åšä»€éº¼ï¼Ÿ

åŸæœ¬ï¼ˆæ²’æœ‰ hashingï¼‰ï¼š

```
æ‰¾è³‡æ–™ â†’ å¾é ­çœ‹åˆ°å°¾ â†’ O(n)
```

ç”¨ Hash Tableï¼š

```
key â†’ ç®—ä½ç½® â†’ ç›´æ¥æ‹¿ â†’ å¹³å‡ O(1)
```

ğŸ“Œ **ç›®æ¨™ï¼ˆGoalï¼‰**

* Quickly find data by a key, without searching through all elements

## 3ï¸âƒ£ Keyâ€“Value Mappingï¼ˆæœ€é‡è¦çš„ä¸€è¡Œï¼‰

```
Key â†’ Hash Function â†’ Index â†’ Value
```

### æ‹†é–‹çœ‹ï¼š

1. **Key**

   * ç”¨ä¾†æ‰¾è³‡æ–™çš„æ±è¥¿ï¼ˆå­¸è™Ÿã€å¸³è™Ÿã€IDï¼‰

2. **Hash Function**

   * ä¸€å€‹æ•¸å­¸è¦å‰‡
   * æŠŠ key è®Šæˆæ•¸å­—

3. **Index**

   * é™£åˆ—çš„ä½ç½®ï¼ˆbucket ç·¨è™Ÿï¼‰

4. **Value**

   * çœŸæ­£å­˜çš„è³‡æ–™

## 4ï¸âƒ£ Hash Function æ˜¯ä»€éº¼ï¼Ÿ

* **Hash Function = æŠŠ key è½‰æˆé™£åˆ— index çš„å…¬å¼**

ä¾‹å¦‚ï¼š

```text
h(k) = k mod 10
```

key = 37
â†’ 37 mod 10 = 7
â†’ å­˜åœ¨ `table[7]`

ğŸ“Œ å¥½çš„ hash functionï¼š

* å¿«
* åˆ†å¸ƒå¹³å‡
* ä¸å®¹æ˜“æ’åœ¨åŒä¸€æ ¼

## 5ï¸âƒ£ ç‚ºä»€éº¼æ˜¯ã€Œaverage O(1)ã€ï¼Ÿ

å› ç‚ºï¼š

* ä¸ç”¨æœå°‹
* ç›´æ¥ç®— index
* ç›´æ¥å­˜ / æ‹¿

âš ï¸ ä½†å‰ææ˜¯ï¼š

* hash function è¨­è¨ˆå¾—å¥½
* collision ä¸åš´é‡

æ‰€ä»¥è€å¸«ä¸€å®šæœƒå¯«ï¼š

* **Average O(1), Worst-case O(n)**

## 6ï¸âƒ£ ä»€éº¼æ˜¯ Collisionï¼ˆç¢°æ’ï¼‰ï¼Ÿ

ğŸ‘‰ **ä¸åŒ key ç®—å‡ºåŒä¸€å€‹ index**

ä¾‹å­ï¼š

```
h(12) = 2
h(22) = 2
```

å…©å€‹ key éƒ½æƒ³æ”¾ `table[2]` ğŸ˜±

## 7ï¸âƒ£ è§£æ±º Collision çš„æ–¹æ³•ï¼ˆè€ƒè©¦å¿…è€ƒï¼‰

### ğŸ”¹ 1. Chainingï¼ˆæ‹‰éŠæ³•ï¼‰

æ¯å€‹ bucket å­˜ä¸€å€‹ linked listï¼š

```
table[2] â†’ (12,A) â†’ (22,B)
```

* æ’å…¥ï¼šä¸Ÿé€² list
* æœå°‹ï¼šåœ¨ list è£¡æ‰¾

ğŸ“Œ å¹³å‡ O(1)ï¼Œæœ€å·® O(n)

---

### ğŸ”¹ 2. Open Addressingï¼ˆé–‹æ”¾å®šå€ï¼‰

æ’åˆ°å°±æ‰¾ä¸‹ä¸€å€‹ç©ºä½ï¼š

* Linear probing
* Quadratic probing
* Double hashing

ä¾‹å­ï¼ˆLinearï¼‰ï¼š

```
2 â†’ è¢«å 
3 â†’ è¢«å 
4 â†’ ç©º â†’ æ”¾é€™
```

---

## 8ï¸âƒ£ è¡¨æ ¼ç¸½æ•´ç†ï¼ˆè¶…å¥½èƒŒï¼‰

| æ¦‚å¿µ              | èªªæ˜                     |
| --------------- | ---------------------- |
| Hashing         | ç”¨ hash function å¿«é€Ÿå­˜å–è³‡æ–™ |
| Hash Table      | å­˜ key-value çš„é™£åˆ—        |
| Hash Function   | key â†’ index            |
| Bucket          | é™£åˆ—çš„ä¸€æ ¼                  |
| Collision       | å…©å€‹ key åŒä¸€ index        |
| Chaining        | ä¸€æ ¼æ”¾ä¸€ä¸²                  |
| Open Addressing | å¾€åˆ¥æ ¼æ‰¾                   |

## 9ï¸âƒ£ ä¸€å¥è©±è€ƒè©¦è¬ç”¨ç­”æ¡ˆ âœ…

* **Hashing uses a hash function to map keys to array indices, enabling fast insertion, deletion, and lookup with average O(1) time.**

---

# è£œå……

## 1ï¸âƒ£ å„è‡ªåœ¨åšä»€éº¼ï¼Ÿï¼ˆç™½è©±ç‰ˆï¼‰

### ğŸ”¹ Hashingï¼ˆé›œæ¹Šï¼‰

* **æ•´å€‹å¿«é€Ÿæ‰¾è³‡æ–™çš„æ¦‚å¿µèˆ‡æµç¨‹**

* ç”¨ key
* ç¶“é hash function
* æ‰¾åˆ°ä½ç½®
* å­˜ / å–è³‡æ–™

ğŸ“Œ **Hashing = Strategyï¼ˆç­–ç•¥ï¼‰**

### ğŸ”¹ Hash Tableï¼ˆé›œæ¹Šè¡¨ï¼‰

* **å¯¦éš›å­˜è³‡æ–™çš„åœ°æ–¹**

* ä¸€å€‹é™£åˆ—ï¼ˆarray of bucketsï¼‰
* æ¯ä¸€æ ¼å¯ä»¥æ”¾ä¸€å€‹æˆ–å¤šå€‹ keyâ€“value

ğŸ“Œ **Hash Table = Containerï¼ˆå®¹å™¨ï¼‰**

### ğŸ”¹ Hash Functionï¼ˆé›œæ¹Šå‡½æ•¸ï¼‰

* **æŠŠ key è½‰æˆ index çš„å…¬å¼**

ä¾‹å¦‚ï¼š

```
h(k) = k mod 10
```

ğŸ“Œ **Hash Function = Toolï¼ˆå·¥å…·ï¼‰**

---

## 2ï¸âƒ£ ç”¨æµç¨‹åœ–ä¸€æ¬¡çœ‹æ‡‚

```
Key
 â†“
Hash Function   â†ï¼ˆé€™æ˜¯å…¬å¼ï¼‰
 â†“
Index
 â†“
Hash Table      â†ï¼ˆé€™æ˜¯é™£åˆ—ï¼‰
 â†“
Value
```

è€Œ **æ•´å€‹æµç¨‹åˆèµ·ä¾†** å°±å«ï¼š

ğŸ‘‰ **Hashing**

---

## 3ï¸âƒ£ è¡¨æ ¼å°ç…§ï¼ˆè€ƒè©¦è¶…å¥½ç”¨ï¼‰

| åç¨±            | é¡å‹      | åœ¨å¹¹å˜›         | ä¸€å¥è©±è¨˜æ†¶  |
| ------------- | ------- | ----------- | ------ |
| Hashing       | æŠ€è¡“ / æ¦‚å¿µ | å¿«é€Ÿæ‰¾è³‡æ–™çš„æ–¹æ³•    | æ•´å€‹æµç¨‹   |
| Hash Table    | è³‡æ–™çµæ§‹    | å­˜ keyâ€“value | æ”¾è³‡æ–™çš„åœ°æ–¹ |
| Hash Function | å‡½æ•¸      | key â†’ index | ç®—ä½ç½®    |

---

# p.21 Table Size

## ç‚ºä»€éº¼ã€Œprefer prime numbersã€ï¼Ÿ

### ğŸ”¹ å•é¡Œï¼špatternï¼ˆè¦å¾‹ï¼‰æœƒé€ æˆ collision

å¦‚æœ **m ä¸æ˜¯è³ªæ•¸**ï¼Œkey å¾ˆå®¹æ˜“ã€Œå°é½ŠåŒæ¨£çš„é¤˜æ•¸ã€ã€‚

#### âŒ m = 1000ï¼ˆä¸æ˜¯è³ªæ•¸ï¼‰

```
h(k) = k mod 1000
```

å¦‚æœ key æœ‰è¦å¾‹ï¼š

```
1000, 2000, 3000, 4000
```

çµæœï¼š

```
1000 mod 1000 = 0
2000 mod 1000 = 0
3000 mod 1000 = 0
```

ğŸ˜± å…¨éƒ¨æ’åœ¨åŒä¸€æ ¼

---

### âœ… m = 1009ï¼ˆè³ªæ•¸ï¼‰

```
1000 mod 1009 = 1000
2000 mod 1009 = 991
3000 mod 1009 = 982
```

ğŸ‘‰ åˆ†å¸ƒæ¯”è¼ƒå¹³å‡
ğŸ‘‰ **é¿å… repeating patterns**

ğŸ“Œ é€™å°±æ˜¯æŠ•å½±ç‰‡èªªçš„ï¼š

* **Prefer prime numbers for m to avoid repeating patterns**

---

# p.24 Collision Handling     

---

# **1. Chainingï¼ˆæ‹‰éŠæ³•ï¼‰**

**æ¦‚å¿µï¼š**
å¦‚æœå…©å€‹ key çš„ hash index ä¸€æ¨£ï¼Œå°±æŠŠå®ƒå€‘**æ”¾åœ¨åŒä¸€å€‹æ¡¶å­ï¼ˆbucketï¼‰è£¡çš„ list**ã€‚

### **ç¤ºæ„åœ–**

```
index 0:  NULL
index 1:  [ (17) â†’ (29) â†’ (45) ]   â† éƒ½è¢« hash åˆ° 1
index 2:  [ (8) ]
index 3:  NULL
```

### **å„ªé»**

* å¯¦ä½œç°¡å–®
* è² è¼‰éé«˜æ™‚ï¼Œåªæœƒè®“ list è®Šé•·ï¼Œä¸æœƒåƒ open addressing é‚£æ¨£çˆ†æ‰

### **ç¼ºé»**

* éœ€è¦é¡å¤– pointerï¼ˆlist çµæ§‹ï¼‰

---

# **2. Open Addressingï¼ˆé–‹æ”¾å®šå€ï¼‰**

**æ¦‚å¿µï¼š**
ç¢°æ’æ™‚ï¼Œä¸æŠŠå¤šé¤˜çš„è³‡æ–™å¡åœ¨åŒä¸€æ¡¶å­ï¼Œè€Œæ˜¯**å¾€å…¶ä»–ç©ºä½æ‰¾ï¼ˆprobeï¼‰**ã€‚

## **ä¸‰ç¨®å¸¸è¦‹æ¢æ¸¬æ–¹å¼**

### **(1) Linear Probingï¼ˆç·šæ€§æ¢æ¸¬ï¼‰**

å¾€å¾Œä¸€æ ¼ã€ä¸€æ ¼ã€ä¸€æ ¼æ‰¾ï¼š

è‹¥åŸæœ¬ index = `h(k)`ï¼Œå‰‡æ¢æ¸¬é †åºç‚º

```
h(k), h(k)+1, h(k)+2, ...
```

ï¼ˆè¨˜å¾—å° table å¤§å°å– moduloï¼‰

**ç¼ºé»ï¼šæœƒç”¢ç”Ÿ clusteringï¼ˆç¾¤èšï¼‰=> ä¸€æ•´æ®µé€£çºŒå€åŸŸéƒ½æœ‰keyã€‚ç¾¤èšè¶Šé•·ï¼Œæ•ˆèƒ½è¶Šå·®**

---

### **(2) Quadratic Probingï¼ˆäºŒæ¬¡æ¢æ¸¬ï¼‰**

ç”¨å¹³æ–¹å¢åŠ è·é›¢é¿å…ç¾¤èšï¼š

```
h(k), h(k)+1Â², h(k)+2Â², h(k)+3Â², ...
```

é™ä½ç¾¤èšï¼Œä½†ä¸ä¿è­‰ä¸€å®šæ‰¾å¾—åˆ°ç©ºä½ï¼ˆè¼ƒä¾è³´ table è¨­è¨ˆï¼‰ã€‚

---

### **(3) Double Hashingï¼ˆé›™é›œæ¹Šï¼‰**

ç•¶ç¢°æ’ç™¼ç”Ÿï¼Œç”¨ç¬¬äºŒå€‹ hash function æ±ºå®šæ­¥é•·ï¼š

```
h(k), h(k) + h2(k), h(k) + 2*h2(k), h(k) + 3*h2(k), ...
```

**å„ªé»ï¼šæœ€ä½³çš„ Open Addressing methodï¼Œä¸å¤ªæœƒç¾¤èšã€‚**

---

# **3. Composite Keyï¼ˆè¤‡åˆéµï¼‰**

**æ¦‚å¿µï¼š**
ä¸åªç”¨å–®ä¸€å€¼åš keyï¼Œè€Œæ˜¯ã€ŒæŠŠå¤šå€‹å±¬æ€§çµ„åˆèµ·ä¾†ã€åš hashï¼Œä»¥é™ä½ç¢°æ’ã€‚

### **ä¾‹å­**

å‡è¨­ä½ è¦å­˜å­¸ç”Ÿè³‡æ–™ï¼š

å¦‚æœåªç”¨ **name** ç•¶ keyï¼Œå…©å€‹äººå« "Kevin" å°± collisionã€‚
æ‰€ä»¥ä½ å¯ä»¥æ”¹ç”¨ï¼š

```
key = hash(name + studentID)
```

æˆ–

```
key = hash(name, birth_year)
```

æˆ–

```
key = hash(value1 + timestamp)
```

å¢åŠ å”¯ä¸€æ€§ â†’ æ¸›å°‘ç¢°æ’ã€‚

### **å¸¸è¦‹å ´æ™¯**

* Database primary key (è¤‡åˆä¸»éµ)
* è³‡æ–™åº« join
* Map / Dictionary å„²å­˜å¤šå±¬æ€§ç‰©ä»¶

---

# **4. Hash Refinementï¼ˆæ”¹å–„é›œæ¹Šå‡½å¼ï¼‰**

**æ¦‚å¿µï¼š**
å¦‚æœ hash function å¤ªå·® â†’ å¾ˆå¤šè³‡æ–™æœƒé›†ä¸­åœ¨æŸäº› index â†’ å®¹æ˜“ç¢°æ’ã€‚
æ‰€ä»¥è¦æ”¹è‰¯ hash function ä¾†ï¼š

* åˆ†æ•£ key
* æ··åˆ bitï¼ˆbit-mixingï¼‰
* å° **å¤§è³ªæ•¸ï¼ˆprimeï¼‰mod** å–é¤˜æ•¸

---

### **å¸¸è¦‹æ”¹å–„æ–¹å¼**

### **(1) Mod å¤§è³ªæ•¸ (mod a large prime)**

ä¾‹å¦‚ table å¤§å°ç”¨ï¼š

**101ã€1009ã€10007ã€131071â€¦**
æ¯” mod 100ã€mod 1000 åˆ†å¸ƒå¥½å¤ªå¤šã€‚

---

### **(2) Better bit-mixing**

åƒ MurmurHashã€xxHashã€FNV-1a éƒ½æ˜¯é«˜å“è³ªçš„ hash functionã€‚
ï¼ˆå°¤å…¶ C èª²ç¨‹ä¸­å¸¸ç”¨ FNV æˆ– DJB2ï¼‰

---

### **(3) Reduce patterns**

å¦‚æœ key æœ‰è¦å¾‹ï¼ˆåƒ 1000ã€2000ã€3000ï¼‰ï¼Œ
å·®çš„ hash æœƒå…¨éƒ¨è½åˆ°åŒ indexã€‚
å¥½ä¸€é»çš„ hash æœƒæŠŠå®ƒå€‘æ‰“æ•£ã€‚

---

# **ç¸½çµåœ–ï¼ˆå¼·åŒ–ç†è§£ï¼‰**

| æ–¹æ³•                  | æ¦‚å¿µ                  | å„ªé»    | ç¼ºé»       |
| ------------------- | ------------------- | ----- | -------- |
| **Chaining**        | åŒ index åš list      | ç°¡å–®ã€ç©©å®š | éœ€è¦ list  |
| **Open Addressing** | æ‰¾ä¸‹ä¸€å€‹ç©º slot          | ä¸éœ€è¦æŒ‡æ¨™ | é«˜è² è¼‰æ™‚å¾ˆæ…¢   |
| **Composite Key**   | ç”¨å¤šå±¬æ€§ä¾†å¢åŠ  key å”¯ä¸€æ€§     | æ¸›å°‘ç¢°æ’  | key è¨ˆç®—è¼ƒé‡ |
| **Hash Refinement** | æ”¹ç”¨æ›´å¥½çš„ hash function | åˆ†å¸ƒæ›´å¹³å‡ | è¨­è¨ˆè¦èŠ±æ™‚é–“   |

---

# p.26 Key Concept

## ä¸€.The data or identifier to be stored è§£é‡‹

* **The data or identifier to be stored**
* **è¦è¢«å­˜é€² hash table çš„è³‡æ–™ï¼Œæˆ–ç”¨ä¾†è¾¨è­˜è³‡æ–™çš„è­˜åˆ¥ç¢¼**

## åœ¨ Hash Table è£¡å®ƒå¯¦éš›æŒ‡çš„æ˜¯ä»€éº¼ï¼Ÿ

ğŸ‘‰ **æŒ‡çš„æ˜¯ã€ŒKeyã€**

ä¹Ÿå°±æ˜¯ï¼š

* hash function çš„è¼¸å…¥
* ç”¨ä¾†æ±ºå®š index çš„æ±è¥¿

---

## ç”¨ä¾‹å­æœ€æ¸…æ¥š

### ğŸ“ å­¸ç”Ÿè³‡æ–™

```
Key   = student ID   â† identifier
Value = student name, GPA, ...
```

é€™è£¡ï¼š

* student ID æ˜¯ **identifier**
* å®ƒæœ¬èº«ä¹Ÿæ˜¯ä¸€ç¨® **data**

---

### ğŸ‘¤ å¸³è™Ÿç³»çµ±

```
Key   = username
Value = user profile
```

usernameï¼š

* æ˜¯è³‡æ–™
* ä¹Ÿæ˜¯ç”¨ä¾†ã€Œè­˜åˆ¥ã€ä½¿ç”¨è€…çš„ key

---

### ğŸ“¦ å­—å…¸ï¼ˆDictionaryï¼‰

```
Key   = "apple"
Value = "è˜‹æœ"
```

"apple"ï¼š

* æ˜¯ data
* ä¹Ÿæ˜¯ identifierï¼ˆç”¨ä¾†æ‰¾åˆ°ç¿»è­¯ï¼‰

---

## è€ƒè©¦æ™‚ä½ å¯ä»¥é€™æ¨£ç†è§£

* **Key æ˜¯ç”¨ä¾†è­˜åˆ¥èˆ‡æŸ¥æ‰¾è³‡æ–™çš„å€¼ï¼Œæœƒè¢«é€é€² hash functionã€‚**
* **Key is the identifier used to locate data in the hash table.**

## ä¸€å¥è©±ç¸½çµ

* ã€ŒThe data or identifier to be storedã€
* å°±æ˜¯æŒ‡ **è¦å­˜é€² hash tableã€ä¸¦ä¸”ç”¨ä¾†ç•¶ä½œæŸ¥æ‰¾ä¾æ“šçš„ key**ã€‚

---

## äºŒ. Load Factor è§£é‡‹ 

```
Load Factor = è² è¼‰ç‡ => Î± = n / mï¼Œè¡¨ç¤ºæ“æ“ ç¨‹åº¦
```
* n = å­˜äº†å¹¾ç­†è³‡æ–™
* m = table size

Q: Î±å¢åŠ æœƒæ€æ¨£    
A: 1.collison(è¡çª)å¢åŠ     
   2.cluster(ç¾¤èš)å¢åŠ     
   3.æœå°‹æ™‚é–“è®Šé•·    

---

# p.27 Hash Function    

---

# âœ… **1. Division Methodï¼ˆé™¤æ³•å–é¤˜æ³•ï¼‰**

## âœ” **å…¬å¼**

```
h(k) = k mod m
```

## âœ” **åŸç†**

ç”¨é™¤æ³•æŠŠ key é™¤ä»¥ mï¼Œå–é¤˜æ•¸ã€‚

## âœ” **ä¾‹å­**

```
key = 123
m = 10
h(123) = 123 mod 10 = 3
```

## âœ” **å„ªé»**

* æœ€ç°¡å–®
* è¨ˆç®—æœ€å¿«

## âœ” **ç¼ºé»**

* å¦‚æœ m é¸å¾—ä¸å¥½ï¼ˆä¾‹å¦‚ m æ˜¯ key çš„æŸç¨®æ¨¡å¼çš„å€æ•¸ï¼‰
  â†’ å¾ˆå®¹æ˜“é€ æˆ clustering

âœ” é€šå¸¸æŠŠ **m é¸æˆè³ªæ•¸**ï¼ˆprime numberï¼‰
æ•ˆæœæœ€å¥½ã€‚

---

# âœ… **2. Multiplication Methodï¼ˆä¹˜æ³•æ³•ï¼‰**

## âœ” **å…¬å¼**

```
h(k) = floor( m * (k*A mod 1) )
```

å…¶ä¸­ï¼š

* A æ˜¯ 0 åˆ° 1 ä¹‹é–“çš„å¯¦æ•¸
* å…¸å‹çš„é¸æ“‡ï¼š

  ```
  A â‰ˆ 0.6180339887  (é»ƒé‡‘æ¯”ä¾‹å°æ•¸éƒ¨åˆ†)
  ```

## âœ” **åŸç†**

åˆ©ç”¨ â€œk*A çš„å°æ•¸éƒ¨åˆ†â€ ä¾†æ‰“æ•£ keyã€‚

å› ç‚ºæµ®é»ä¹˜æ•¸ä¸€èˆ¬èƒ½è®“éµåˆ†å¸ƒæ›´å‡å‹»ï¼Œæ‰€ä»¥**ä¸éœ€è¦å¤ªåœ¨æ„ m æ˜¯ä¸æ˜¯è³ªæ•¸**ã€‚

## âœ” **ä¾‹ï¼ˆç°¡åŒ–ç¤ºæ„ï¼‰**

å‡è¨­ A = 0.618   
k = 123   
m = 10   

```
123 * 0.618 = 75.999...
å°æ•¸éƒ¨åˆ†ç´„ = 0.999
m * 0.999 â‰ˆ 9.99
floor â†’ 9
```

â†’ index = **9**

---

# âœ… **3. Folding Methodï¼ˆæ‘ºç–Šæ³•ï¼‰**

## âœ” **æƒ³æ³•**

æŠŠ key åˆ†æ®µ â†’ é€æ®µç›¸åŠ  â†’ åŠ ç¸½å¾Œå†åš modã€‚

å¸¸ç”¨æ–¼ **éå¸¸å¤§çš„ key**ï¼Œåƒï¼š

* èº«åˆ†è­‰å­—è™Ÿ
* é›»è©±è™Ÿç¢¼
* ç¤¾æœƒå®‰å…¨ç¢¼
* é•·æ•´æ•°

## âœ” **ä¾‹å­**

key = 123456
åˆ‡æˆä¸‰æ®µï¼š

```
12   34   56
```

ç›¸åŠ ï¼š

```
12 + 34 + 56 = 102
```

æœ€å¾Œæœƒé€šå¸¸åš mod mï¼ˆä¾‹å­æ²’å¯«ï¼Œä½†å¯¦éš›æœƒç”¨ï¼‰ï¼š

```
index = 102 mod m
```

---

# âœ… **4. String Hashingï¼ˆå­—ä¸²é›œæ¹Šï¼‰**

**æœ€é‡è¦ã€æœ€å¸¸ç”¨**
å­—å…¸ã€Symbol Tableã€Compiler è§£æç¬¦è™Ÿï¼Œå…¨éƒ½ç”¨å®ƒã€‚

## âœ” **å…¬å¼ï¼ˆPolynomial Rolling Hashï¼‰**

```
h(s) = ( Î£ s[i] * p^i ) mod m
```

å…¶ä¸­ï¼š

* `s[i]` æ˜¯å­—å…ƒçš„ ASCIIï¼ˆæˆ– Unicodeï¼‰ç¢¼
* `p` æ˜¯ baseï¼Œå¸¸ç”¨ 31ã€131ã€257 â€¦
* `m` æ˜¯å¤§è³ªæ•¸

## âœ” **ä¾‹å­ï¼ˆç¤ºæ„ï¼‰**

å­—ä¸² `"cat"`ï¼š

```
c = 99
a = 97
t = 116
p = 31
```

```
h("cat") = 99*31^0 + 97*31^1 + 116*31^2
```

æ³¨æ„æœ€å¾Œä»æœƒ mod mã€‚

## âœ” **ç‰¹é»**

* åˆ†å¸ƒå¥½
* é¿å… collision
* ç”¨æ–¼ï¼š

  * C++ std::string hash
  * Java String hash
  * æ»¾å‹•é›œæ¹Šï¼ˆRabinâ€“Karp æ¼”ç®—æ³•ï¼‰

---

# ğŸ‰ **ç¸½è¡¨æ•´ç†**

| Method                          | Formula / Idea                                               | Example                         |
| ------------------------------- | ------------------------------------------------------------ | ------------------------------- |
| **Division Method**             | `h(k) = k mod m`                                             | `key = 123, m = 10 â†’ index = 3` |
| **Multiplication Method**       | `h(k) = floor(m * (k*A mod 1))`, `0 < A < 1`, å¸¸ç”¨ `A â‰ˆ 0.618` | ä¹˜æ³•æ³•ç¤ºæ„ â†’ index â‰ˆ 9               |
| **Folding Method**              | æ‹†æˆå¤šæ®µå¾Œç›¸åŠ                                                       | `123456 â†’ 12+34+56 = 102`       |
| **String Hashing (Polynomial)** | `h(s) = ( Î£ s[i] * p^i ) mod m`                              | å­—ä¸² `"cat"` â†’ 99 + 97*31 + ...   |

---

# p.29 Comparison

## ç°¡ä»‹

* **Static hashing** ä½¿ç”¨å›ºå®šå¤§å°çš„ hash tableï¼Œç•¶è³‡æ–™è®Šå¤šæ™‚æ•ˆèƒ½æœƒä¸‹é™ï¼›
* **Dynamic hashing** æœƒéš¨è³‡æ–™é‡èª¿æ•´çµæ§‹ï¼Œä½¿æ•ˆèƒ½åœ¨é«˜ load factor ä¸‹ä»èƒ½ç¶­æŒã€‚

## é€åˆ—è§£é‡‹é€™å¼µè¡¨åœ¨æ•™çš„è§€å¿µ

### 1ï¸âƒ£ Table Size

| Static | Dynamic  |
| ------ | -------- |
| Fixed  | Variable |

### åœ¨æ•™ä»€éº¼ï¼Ÿ

* **Static hashing**

  * ä¸€é–‹å§‹å°±æ±ºå®š table size `m`
  * ä¹‹å¾Œä¸èƒ½è®Š

* **Dynamic hashing**

  * table æœƒè‡ªå‹•é•·å¤§æˆ–ç¸®å°
  * ä¸ç”¨äº‹å…ˆçŒœè³‡æ–™é‡

ğŸ“Œ æ•™ä½ ï¼š**èƒ½ä¸èƒ½é©æ‡‰è³‡æ–™æˆé•·**

---

### 2ï¸âƒ£ Hash Function

| Static   | Dynamic  |
| -------- | -------- |
| Constant | Adaptive |

### åœ¨æ•™ä»€éº¼ï¼Ÿ

* Staticï¼š

  ```
  index = h(key) mod m
  ```

  æ°¸é ä¸€æ¨£

* Dynamicï¼š

  * æœƒä¾ç›®å‰ table ç‹€æ…‹
  * ä½¿ç”¨æ›´å¤š bits / ä¸åŒå±¤ç´š

ğŸ“Œ æ•™ä½ ï¼š**hash function æ˜¯å¦æœƒè·Ÿè‘—çµæ§‹è®Š**

---

### 3ï¸âƒ£ Memory Usage

| Static      | Dynamic    |
| ----------- | ---------- |
| Predictable | May expand |

### åœ¨æ•™ä»€éº¼ï¼Ÿ

* Staticï¼š

  * è¨˜æ†¶é«”ç”¨é‡å›ºå®š
  * å¥½é ä¼°

* Dynamicï¼š

  * æœƒ allocate æ–° bucket
  * ç”¨é‡å½ˆæ€§ä½†ä¸å¯é æœŸ

ğŸ“Œ æ•™ä½ ï¼š**è¨˜æ†¶é«”ç®¡ç†çš„å–æ¨**

---

### 4ï¸âƒ£ Performanceï¼ˆÎ± â†‘ï¼‰

| Static   | Dynamic           |
| -------- | ----------------- |
| Degrades | Remains efficient |

### åœ¨æ•™ä»€éº¼ï¼Ÿ

* Staticï¼š

  * Î± = n / m
  * n â†‘ â†’ Î± â†‘ â†’ collision â†‘

* Dynamicï¼š

  * ç•¶ Î± å¤ªé«˜
  * è‡ªå‹• split bucket
  * è®“ Î± ç¶­æŒåœ¨åˆç†ç¯„åœ

ğŸ“Œ **é€™ä¸€åˆ—æ˜¯æ ¸å¿ƒé‡é»**

---

### 5ï¸âƒ£ Rehashing

| Static       | Dynamic      |
| ------------ | ------------ |
| Entire table | Local splits |

### åœ¨æ•™ä»€éº¼ï¼Ÿ

* Staticï¼š

  * table æ»¿äº†
  * **å…¨éƒ¨è³‡æ–™é‡ç®— hash**
  * æˆæœ¬å¾ˆé«˜

* Dynamicï¼š

  * åªæ‹†æŸä¸€å€‹ bucket
  * å½±éŸ¿ç¯„åœå°

ğŸ“Œ æ•™ä½ ï¼š**æ“´å……æ™‚çš„ä»£åƒ¹**

---

### 6ï¸âƒ£ Implementation

| Static | Dynamic |
| ------ | ------- |
| Simple | Complex |

### åœ¨æ•™ä»€éº¼ï¼Ÿ

* Staticï¼š

  * array + hash function
  * å®¹æ˜“å¯¦ä½œã€å®¹æ˜“æ•™

* Dynamicï¼š

  * directory
  * pointers
  * local depth / global depth

ğŸ“Œ æ•™ä½ ï¼š**å¯¦ä½œé›£åº¦**

---

### 7ï¸âƒ£ Best Use Case

| Static       | Dynamic        |
| ------------ | -------------- |
| Small, fixed | Large, growing |

### åœ¨æ•™ä»€éº¼ï¼Ÿ

* Staticï¼š

  * è³‡æ–™é‡äº‹å…ˆçŸ¥é“
  * ä¸å¤ªæœƒè®Š

* Dynamicï¼š

  * è³‡æ–™ä¸€ç›´åŠ 
  * è³‡æ–™åº«ã€æª”æ¡ˆç³»çµ±

ğŸ“Œ æ•™ä½ ï¼š**å¯¦å‹™é¸æ“‡ä¾æ“š**

---

## çœŸæ­£é‡é»

* â“ã€Œè³‡æ–™æœƒä¸æœƒæˆé•·ï¼Ÿã€

* **ä¸æœƒ â†’ Static Hashing**
* **æœƒ â†’ Dynamic Hashing**

## è€ƒè©¦ä¸€è¡Œç­”æ¡ˆ

* Static hashing uses a fixed-size table and degrades as the load factor increases, while dynamic hashing adapts its structure by splitting buckets to maintain performance as data grows.

## å¿«é€Ÿè¨˜æ†¶å£è¨£

* Staticï¼š**å…ˆå®šæ­»ã€æ»¿äº†é‡ä¾†**
* Dynamicï¼š**é‚Šç”¨é‚Šé•·ã€å±€éƒ¨èª¿æ•´**

---

# è£œå……ï¼šå•é¡Œ1ï¸âƒ£ ä»€éº¼å«ã€Œè‡ªå‹• split bucketã€ï¼Ÿ

## å…ˆç”¨ä¸€å¥è©±è¬›æ¸…æ¥š

* **è‡ªå‹• split bucket** = ç•¶æŸä¸€å€‹ bucket è£¡çš„è³‡æ–™å¤ªå¤šæ™‚ï¼Œ**åªæŠŠé€™å€‹ bucket æ‹†æˆå…©å€‹**ï¼Œè€Œä¸æ˜¯æ•´å¼µ hash table é‡å»ºã€‚

## å…ˆå›é¡§ï¼šbucket æ˜¯ä»€éº¼ï¼Ÿ

åœ¨ hashing è£¡ï¼š

* **bucket** = ä¸€å€‹ index å°æ‡‰çš„å„²å­˜å–®ä½
* å¯èƒ½æ˜¯ï¼š

  * ä¸€å€‹ page
  * ä¸€å€‹ linked list
  * ä¸€å€‹å°é™£åˆ—

```
index 5  â†’ bucket 5 â†’ [k1, k2, k3, k4]
```

## Static Hashing ç™¼ç”Ÿä»€éº¼äº‹ï¼Ÿ

bucket æ»¿äº†ï¼š

* collision â†‘
* clustering â†‘
* æŸ¥æ‰¾æ…¢

è§£æ³•åªæœ‰ä¸€å€‹ï¼š
ğŸ‘‰ **æ•´å¼µè¡¨ rehashï¼ˆé‡ä¾†ï¼‰**

---

## Dynamic Hashing åœ¨åšä»€éº¼ï¼Ÿ

### æƒ…å¢ƒ

å‡è¨­ï¼š

* æ¯å€‹ bucket æœ€å¤šæ”¾ **3 ç­†**
* bucket 5 å·²ç¶“æ»¿äº†ï¼š

```
bucket 5: [k1, k2, k3]  â† æ»¿
```

### ğŸ”¹ è‡ªå‹• split bucketï¼ˆé‡é»ï¼‰

Dynamic hashing æœƒï¼š

1ï¸âƒ£ **æ–°å¢ä¸€å€‹ bucket**
2ï¸âƒ£ æŠŠåŸæœ¬ bucket 5 çš„è³‡æ–™
3ï¸âƒ£ ç”¨ã€Œå¤šä¸€å€‹ bitã€é‡æ–°åˆ†é…

çµæœè®Šæˆï¼š

```
bucket 5:  [k1, k3]
bucket 13: [k2]
```

ğŸ“Œ **åªæœ‰é€™å€‹ bucket è¢«å½±éŸ¿**

ğŸ‘‰ é€™å°±å« **bucket split**

## ç‚ºä»€éº¼å«ã€Œè‡ªå‹•ã€ï¼Ÿ

å› ç‚ºï¼š

* ç¨‹å¼æœƒç›£æ§ï¼š

  * bucket overflow
  * load factor
* ä¸€è¶…éé–€æª»
* **ç³»çµ±è‡ªå·±åš split**

ä½ ä¸ç”¨æ‰‹å‹• resizeã€‚

---

# å•é¡Œ 2ï¸âƒ£ï¼šRehashing é‚£é‚Šç‚ºä»€éº¼çœ‹ä¸æ‡‚ï¼Ÿ

é€™ä¸€åˆ—åœ¨å°æ¯”çš„æ˜¯ï¼š

* **ã€Œæ“´å……æ™‚ï¼Œè³‡æ–™è¦é‡æ–°ç®— hash çš„ç¯„åœã€**

## Static Hashing çš„ Rehashing

### æƒ…æ³

```
table size = 10
n = 9   â†’ Î± = 0.9ï¼ˆå¾ˆæ»¿ï¼‰
```

è¦ resize â†’ `m = 20`

### ç™¼ç”Ÿä»€éº¼äº‹ï¼Ÿ

âŒ **å…¨éƒ¨è³‡æ–™éƒ½è¦é‡ç®—**

```
for every key in table:
    new_index = hash(key) mod 20
    move key
```

ğŸ‘‰ **æ•´å¼µè¡¨æ¬å®¶**

ğŸ“Œ æˆæœ¬ï¼š

* O(n)
* éå¸¸æ…¢

## Dynamic Hashing çš„ Rehashingï¼ˆé‡é»ï¼‰

### é—œéµè§€å¿µ

* Dynamic hashing **å¹¾ä¹ä¸åšã€Œæ•´å¼µè¡¨ rehashã€**

å®ƒåªåšï¼š

* **local rehashï¼ˆå±€éƒ¨é‡ç®—ï¼‰**

### ç™¼ç”Ÿä»€éº¼äº‹ï¼Ÿ

* åªæœ‰ï¼š

  * è¢« split çš„é‚£å€‹ bucket
* è£¡é¢çš„ keys
* **é‡æ–°åˆ†é…**

å…¶ä»– bucketsï¼š

* å®Œå…¨ä¸å‹•

### å°ç…§

| é¡å‹              | å“ªäº›è³‡æ–™è¦é‡ç®— hash           |
| --------------- | ---------------------- |
| Static Hashing  | **å…¨éƒ¨**                 |
| Dynamic Hashing | **åªæœ‰è¢« split çš„ bucket** |

## ç”¨ä¸€å¥è¶…ç™½è©±çš„æ¯”å–» ğŸŒ±

### Static Hashing

* æˆ¿é–“æ»¿äº† â†’ **æ•´æ£Ÿå¤§æ¨“æ‹†æ‰é‡è“‹**

### Dynamic Hashing

* æŸä¸€é–“æˆ¿å¤ªæ“  â†’ **åªæŠŠé€™é–“éš”æˆå…©é–“**

## ç‚ºä»€éº¼é€™èƒ½ç¶­æŒæ•ˆèƒ½ï¼Ÿ

å› ç‚ºï¼š

* collision ä¸æœƒå…¨è¡¨æ“´æ•£
* load factor è¢«ã€Œå±€éƒ¨ä¿®æ­£ã€
* æŸ¥æ‰¾æ™‚é–“æ¥è¿‘ O(1)

## æ„›è€ƒæ€éº¼å¯«ï¼ˆç¯„æœ¬ï¼‰

* In dynamic hashing, when a bucket overflows, only that bucket is split and its contents are rehashed locally, avoiding the expensive rehashing of the entire table required in static hashing.

---

# è£œå……3ï¼šç”¨ã€Œå¤šä¸€å€‹ bitã€é‡æ–°åˆ†é… æ˜¯ç”šéº¼

## æ¦‚å¿µ

* **å¤šä¸€å€‹ bit** çš„æ„æ€æ˜¯ï¼šåŸæœ¬åªçœ‹ hash å€¼çš„å‰ *k* å€‹ bits ä¾†æ±ºå®š bucketï¼Œbucket æ»¿äº†ä»¥å¾Œï¼Œ**æ”¹æˆçœ‹å‰ *k+1* å€‹ bits**ï¼Œæ–¼æ˜¯è³‡æ–™è‡ªç„¶è¢«åˆ†æˆå…©ç¾¤ã€‚

## å…ˆå»ºç«‹å…±åŒèƒŒæ™¯

### hash function çš„è¼¸å‡ºæ˜¯ä»€éº¼ï¼Ÿ

ä¸æ˜¯ indexï¼Œè€Œæ˜¯ä¸€ä¸² **binary bits**ï¼š

```
hash(key) = 010110101011...
```

Dynamic hashing ä¸æœƒä¸€é–‹å§‹å°±ç”¨å®Œå…¨éƒ¨ bitsã€‚

## åŸæœ¬æ€éº¼æ”¾è³‡æ–™ï¼Ÿï¼ˆé‚„æ²’ splitï¼‰

å‡è¨­ï¼š

* ç›®å‰åªç”¨ **å‰ 2 å€‹ bits**
* bucket ç”¨é€™ 2 bits æ±ºå®š

```
00 â†’ bucket A
01 â†’ bucket B
10 â†’ bucket C
11 â†’ bucket D
```

æŸä¸€å€‹ bucketï¼ˆä¾‹å¦‚ `01`ï¼‰å¡æ»¿äº†ã€‚

## ç™¼ç”Ÿ split æ™‚ï¼šå¤šçœ‹ 1 å€‹ bit

### åŸæœ¬åªçœ‹ 2 bitsï¼š

```
01
```

### ç¾åœ¨æ”¹æˆçœ‹ 3 bitsï¼š

```
010 â†’ æ–° bucket 1
011 â†’ æ–° bucket 2
```

ğŸ‘‰ **åŸæœ¬å±¬æ–¼ `01` çš„è³‡æ–™ï¼Œæœƒè¢«è‡ªå‹•åˆ†æˆå…©é¡**

## ç”¨å¯¦éš› key è·‘ä¸€æ¬¡ï¼ˆå¾ˆé‡è¦ï¼‰

å‡è¨­é€™äº› key çš„ hash çµæœæ˜¯ï¼š

| Key | hash(key) |
| --- | --------- |
| k1  | 010011... |
| k2  | 011101... |
| k3  | 010110... |
| k4  | 011000... |

### split å‰ï¼ˆçœ‹å‰ 2 bitsï¼‰

```
01 â†’ [k1, k2, k3, k4]  â† çˆ†äº†
```

### split å¾Œï¼ˆçœ‹å‰ 3 bitsï¼‰

```
010 â†’ [k1, k3]
011 â†’ [k2, k4]
```

ğŸ“Œ **æ²’æœ‰äººå·¥åˆ†é¡ï¼Œæ˜¯ bit è‡ªå·±æ±ºå®šçš„**

## ç‚ºä»€éº¼é€™æ¨£å°±èƒ½å¹³å‡ï¼Ÿ

å› ç‚ºï¼š

* å¥½çš„ hash function
* bits æ˜¯äº‚çš„ã€å‡å‹»çš„

ğŸ‘‰ å¤šçœ‹ä¸€å€‹ bit â‰ˆ **å†ä¸Ÿä¸€æ¬¡å…¬å¹³çš„ç¡¬å¹£**

## ç‚ºä»€éº¼ä¸æ˜¯å…¨éƒ¨ bucket éƒ½å¤šä¸€å€‹ bitï¼Ÿ

å› ç‚ºï¼š

* åªæœ‰é€™å€‹ bucket æ»¿
* å…¶ä»– bucket é‚„å¥½

ğŸ‘‰ æ‰€ä»¥æ˜¯ **local depth +1**

## è·Ÿ Static Hashing çš„å·®åˆ¥ï¼ˆé—œéµï¼‰

| Static Hashing       | Dynamic Hashing  |
| -------------------- | ---------------- |
| index = h(key) mod m | index = å‰ k bits |
| m è®Š â†’ å…¨è¡¨é‡ç®—           | k åªå°è©² bucket å¢åŠ   |
| é‡ä¾†ä¸€æ¬¡                 | å±€éƒ¨èª¿æ•´             |

## è€å¸«è¦ä½ è¨˜ä½çš„è€ƒè©¦å¥

* When a bucket overflows in dynamic hashing, one additional bit of the hash value is used to split the bucket, redistributing its records into two new buckets.

---

# p.38 What is Probing?    

---

# âœ… **Probingï¼ˆæ¢æ¸¬æ³•ï¼‰**

**å®šç¾©ï¼š**

> Probing æ˜¯ **è§£æ±ºç¢°æ’ï¼ˆcollisionï¼‰** çš„æ–¹æ³•ï¼Œç”¨æ–¼ **Open Addressingï¼ˆé–‹æ”¾å®šå€ï¼‰Hash Table**ã€‚
> ç•¶å¤šå€‹ key è¢« hash åˆ°ç›¸åŒ index æ™‚ï¼Œproving æ±ºå®š **å¦‚ä½•å°‹æ‰¾ä¸‹ä¸€å€‹å¯ç”¨ä½ç½®**ã€‚

---

# ğŸ§© **å…¬å¼åŒ–èªªæ³•**

```
Probing = ç³»çµ±æ€§æœå°‹ hash table ä¸­çš„ç©ºæ§½ï¼ˆempty slotï¼‰ï¼Œç›´åˆ°æ‰¾åˆ°å¯ä»¥æ”¾ç½®çš„ index
```

* hash index = h(key)
* å¦‚æœè©²ä½ç½®å·²è¢«ä½”ç”¨ â†’ ç”¨ probing æ‰¾ä¸‹ä¸€å€‹ç©ºä½

---

# ğŸ”¹ **å¸¸è¦‹ Probing æ–¹æ³•**

1. **Linear Probingï¼ˆç·šæ€§æ¢æ¸¬ï¼‰**

   ```
   h(k), h(k)+1, h(k)+2, ...
   ```

   å„ªé»ï¼šç°¡å–®
   ç¼ºé»ï¼šå®¹æ˜“ç¾¤èšï¼ˆclusteringï¼‰

2. **Quadratic Probingï¼ˆäºŒæ¬¡æ¢æ¸¬ï¼‰**

   ```
   h(k), h(k)+1Â², h(k)+2Â², h(k)+3Â², ...
   ```

   å„ªé»ï¼šæ¸›å°‘ç¾¤èš
   ç¼ºé»ï¼šä¸ä¿è­‰ä¸€å®šæ‰¾åˆ°ç©ºä½

3. **Double Hashingï¼ˆé›™é›œæ¹Šï¼‰**

   ```
   h(k), h(k) + h2(k), h(k) + 2*h2(k), ...
   ```

   å„ªé»ï¼šç¾¤èšæœ€å°‘
   ç¼ºé»ï¼šéœ€è¨­è¨ˆç¬¬äºŒå€‹ hash function

---

# ğŸ§  **è£œå……ç†è§£**

* **ç›®çš„**ï¼šé¿å…åœ¨ open addressing ä¸­å› ç¢°æ’è€Œç„¡æ³•æ’å…¥è³‡æ–™
* **ç‰¹é»**ï¼šæ‰€æœ‰è³‡æ–™ä»å­˜æ–¼å–®ä¸€ tableï¼Œæ²’æœ‰éˆçµä¸²åˆ—
* **æ•ˆç‡**ï¼šå–æ±ºæ–¼ **load factor Î»**ï¼ŒÎ» è¶Šå¤§ï¼Œproving æ¬¡æ•¸è¶Šå¤š

---

# ğŸ”¹ **ä¸€å¥è©±ç¸½çµ**

> **Probing = ç¢°æ’å¾Œï¼Œä¾è¦å‰‡åœ¨ hash table ä¸­æ‰¾ä¸‹ä¸€å€‹ç©ºä½çš„ç³»çµ±æ€§æœå°‹æ–¹æ³•ã€‚**

---

# p.39 Typing of Probing   

---

# âœ… **Typing of Probingï¼ˆæ¢æ¸¬æ³•é¡å‹ï¼‰**

| **Method**            | **Formula**                   | **Behaviorï¼ˆè¡Œç‚ºï¼‰**          | **Pros / Consï¼ˆå„ªç¼ºé»ï¼‰**                                         |
| --------------------- | ----------------------------- | ------------------------- | ------------------------------------------------------------ |
| **Linear Probing**    | `(h(k) + i) mod m`            | æ¯æ¬¡æª¢æŸ¥ä¸‹ä¸€å€‹ slotï¼ˆä¾åºæª¢æŸ¥ï¼‰        | **Pros:** ç°¡å–®å¯¦ä½œ<br>**Cons:** å®¹æ˜“ç”¢ç”Ÿ **Primary Clustering**ï¼ˆç¾¤èšï¼‰  |
| **Quadratic Probing** | `(h(k) + câ‚Â·i + câ‚‚Â·iÂ²) mod m` | æ¯æ¬¡æ¢æ¸¬é–“è·å‘ˆäºŒæ¬¡å¢åŠ                | **Pros:** æ¸›å°‘ç¾¤èš<br>**Cons:** å¯èƒ½è·³éä¸€äº› slotï¼Œè¡¨å®¹é‡å¿…é ˆç²¾å¿ƒé¸æ“‡            |
| **Double Hashing**    | `(h1(k) + iÂ·h2(k)) mod m`     | ç”¨ç¬¬äºŒå€‹ hash function æ±ºå®šæ¢æ¸¬æ­¥é•· | **Pros:** åˆ†å¸ƒå‡å‹»ï¼Œç¾¤èšæœ€å°‘<br>**Cons:** è¨ˆç®—é‡è¼ƒå¤§ï¼Œéœ€è¦è¨­è¨ˆç¬¬äºŒå€‹ hash function |

---

# ğŸ”¹ **è£œå……èªªæ˜**

* `i` = æ¢æ¸¬åºåˆ—ç´¢å¼• (0,1,2,â€¦)
* `h(k), h1(k), h2(k)` = hash function(s)
* `m` = hash table å¤§å°

## âœ” **ç†è§£é—œéµ**

1. Linear â†’ ç°¡å–®ä½†ç¾¤èš
2. Quadratic â†’ æ¸›å°‘ç¾¤èšï¼Œä½†å¯èƒ½æ‰¾ä¸åˆ°ç©ºä½ï¼ˆéœ€ Î» < 0.5ï¼‰
3. Double Hashing â†’ æœ€ä½³ open addressing æ–¹æ³•ï¼Œä½†éœ€è¦é¡å¤–è¨ˆç®—

---

# ğŸ”¹ **ä¸€å¥è©±è¨˜æ†¶æŠ€å·§**

> Linear â†’ ç›´èµ°
> Quadratic â†’ è·³å¾—è¶Šä¾†è¶Šé 
> Double â†’ ç”¨å¦ä¸€æŠŠå°ºé‡æ­¥é•·

---

# p.40-41 Linear Probing   

---

# **å‰æ**

* Hash functionï¼š`h(k) = k mod m`
* Table sizeï¼š`m = 10` â†’ slots 0~9
* Collision è™•ç†æ–¹æ³•ï¼š**Linear Probing**

  ```
  index(i) = (h(k) + i) mod m
  i = 0,1,2,...
  ```
* è¦æ’å…¥çš„ keyï¼š23, 33, 43

---

# **Step 1: æ’å…¥ 23**

1. è¨ˆç®— hash indexï¼š

   ```
   h(23) = 23 mod 10 = 3
   ```
2. æª¢æŸ¥ slot[3] æ˜¯å¦ç©ºçš„ï¼š

   * slot[3] ç©º â†’ ç›´æ¥æ”¾å…¥ 23
     âœ… æ’å…¥æˆåŠŸ

**Table ç‹€æ…‹ï¼š**

```
slot[3] = 23
```

---

# **Step 2: æ’å…¥ 33**

1. è¨ˆç®— hash indexï¼š

   ```
   h(33) = 33 mod 10 = 3
   ```
2. slot[3] å·²ç¶“è¢« 23 ä½”ç”¨ â†’ **ç™¼ç”Ÿ collision**
3. Linear Probing é–‹å§‹æ¢æ¸¬ï¼š

   ```
   i = 1 â†’ (3 + 1) mod 10 = 4
   ```
4. æª¢æŸ¥ slot[4]ï¼š

   * slot[4] ç©º â†’ æ’å…¥ 33
     âœ… æ’å…¥æˆåŠŸ

**Table ç‹€æ…‹ï¼š**

```
slot[3] = 23
slot[4] = 33
```

---

# **Step 3: æ’å…¥ 43**

1. è¨ˆç®— hash indexï¼š

   ```
   h(43) = 43 mod 10 = 3
   ```
2. slot[3] å·²è¢«ä½”ç”¨ â†’ collision
3. Linear Probing é–‹å§‹æ¢æ¸¬ï¼š

   ```
   i = 1 â†’ (3 + 1) mod 10 = 4
   ```

   * slot[4] å·²è¢« 33 ä½”ç”¨ â†’ collision

   ```
   i = 2 â†’ (3 + 2) mod 10 = 5
   ```

   * slot[5] ç©º â†’ æ’å…¥ 43
     âœ… æ’å…¥æˆåŠŸ

**Table ç‹€æ…‹ï¼š**

```
slot[3] = 23
slot[4] = 33
slot[5] = 43
```

---

# **è§€å¯Ÿï¼ˆObservationï¼‰**

1. Linear Probing ä¾åºæª¢æŸ¥ä¸‹ä¸€å€‹ slot â†’ **å¾ˆç›´è¦ºã€ç°¡å–®**
2. ç¼ºé»ï¼š**Primary Clustering**

   * é€£çºŒçš„ collision æœƒè®“é€™æ®µå€åŸŸçš„ slots è¶Šä¾†è¶Šæ“æ“ 
   * æœªä¾†æ’å…¥çš„ key å¯èƒ½è¦è·³éå¥½å¹¾å€‹ slot æ‰èƒ½æ‰¾åˆ°ç©ºä½
   * æœå°‹ / æ’å…¥æ•ˆç‡ä¸‹é™

---

# **ä¸€å¥è©±ç†è§£**

> Linear Probing åšçš„äº‹æƒ…å°±æ˜¯ï¼š**ç¢°åˆ° collision â†’ å¾€ä¸‹ä¸€æ ¼æ ¼æª¢æŸ¥ â†’ ç›´åˆ°æ‰¾åˆ°ç©ºä½ç‚ºæ­¢**ã€‚
> æ’å…¥çš„é †åºæœƒå½¢æˆã€Œä¸€æ¢é€£çºŒçš„ filled slotsã€å€å¡Šï¼Œå°±æ˜¯ primary clustering çš„ä¾†æºã€‚

---

# p.42 Primary Clustering   

---

# âœ… **Primary Clusteringï¼ˆä¸»ç¾¤èšï¼‰**

**å®šç¾©ï¼š**

> åœ¨ **Open Addressing Hash Table**ï¼ˆå°¤å…¶æ˜¯ **Linear Probing**ï¼‰ä¸­ï¼Œ**é€£çºŒçš„å·²ä½”ç”¨æ§½ï¼ˆslotsï¼‰å½¢æˆç¾¤èš**ï¼Œ
> å°è‡´å¾ŒçºŒæ’å…¥çš„æ–° key éœ€è¦æª¢æŸ¥æ›´é•·çš„æ¢æ¸¬åºåˆ—ï¼Œè®“ç¾¤èšè®Šå¾—æ›´å¤§ã€‚

---

# ğŸ”¹ **ç‰¹å¾µ**

1. ä¸€æ—¦å‡ºç¾ä¸€æ®µé€£çºŒçš„å·²ä½”ç”¨ slots â†’ å®ƒå®¹æ˜“ **å¸å¼•æ›´å¤šç¢°æ’**
2. æ–°æ’å…¥çš„ key å¾€å¾€è¦ **æ²¿è‘—é€™å€‹ cluster ä¸€æ ¼ä¸€æ ¼æ‰¾ç©ºä½**
3. Cluster è¶Šå¤§ â†’ å¹³å‡æ’å…¥ / æœå°‹æ™‚é–“è¶Šé•·

---

# ğŸ”¹ **ç¤ºæ„ä¾‹å­**

å‡è¨­ hash table m = 10ï¼ŒLinear Probingï¼š

| slot | 0 | 1 | 2 | 3  | 4  | 5  | 6 | 7 | 8 | 9 |
| ---- | - | - | - | -- | -- | -- | - | - | - | - |
| key  |   |   |   | 23 | 33 | 43 |   |   |   |   |

* slots 3~5 å½¢æˆ **cluster**
* å¾ŒçºŒè¦æ’å…¥ key â†’ hash index = 3ï¼ˆç¢°æ’ï¼‰

  * éœ€è¦æª¢æŸ¥ slot 3 â†’ 4 â†’ 5 â†’ 6 æ‰æ‰¾åˆ°ç©ºä½
* Cluster è¶Šä¾†è¶Šå¤§ â†’ æœå°‹æˆæœ¬ä¸Šå‡

---

# ğŸ”¹ **ä¸€å¥è©±ç†è§£**

> **Primary Clustering = é€£çºŒå¡«æ»¿çš„æ§½å½¢æˆâ€œæ“æ“ å€â€ï¼Œè¶Šå¤§è¶Šå®¹æ˜“è®“æ–° key ç¢°æ’ â†’ å¹³å‡æ¢æ¸¬é•·åº¦å¢åŠ ã€‚**

---

# ğŸ”¹ **è§£æ±ºæ–¹å¼**

1. **Quadratic Probing** â†’ gaps grow quadratically â†’ æ¸›å°‘ç¾¤èš
2. **Double Hashing** â†’ ç”¨ç¬¬äºŒå€‹ hash function â†’ åˆ†å¸ƒæ›´å‡å‹»
3. **Chaining** â†’ ç”¨éˆçµä¸²åˆ— â†’ æ²’æœ‰ cluster å•é¡Œ

---

# p.43-44 Quadratic Probing   

---

# **å‰æ**

* Table sizeï¼š`m = 10`ï¼ˆslots 0~9ï¼‰
* Hash functionï¼š`h(k) = k mod 10`
* Collision è§£æ±ºï¼š**Quadratic Probing**

  ```
  index(i) = (h(k) + c1*i + c2*i^2) mod m
  ```
* é€™è£¡å‡è¨­ï¼š`c1 = 1, c2 = 1`
* è¦æ’å…¥çš„ keysï¼š23, 33, 43

---

# **Step 1: æ’å…¥ 23**

1. è¨ˆç®—åˆå§‹ indexï¼š

   ```
   h(23) = 23 mod 10 = 3
   i = 0 â†’ index = (3 + 0 + 0) mod 10 = 3
   ```
2. slot[3] ç©º â†’ æ’å…¥ 23
   âœ… æ’å…¥æˆåŠŸ

**Table ç‹€æ…‹ï¼š**

```
slot[3] = 23
```

---

# **Step 2: æ’å…¥ 33**

1. è¨ˆç®—åˆå§‹ indexï¼š

   ```
   h(33) = 33 mod 10 = 3
   i = 0 â†’ index = 3 (slot[3] å·²è¢« 23 ä½”ç”¨)
   ```
2. Collision â†’ é–‹å§‹ Quadratic Probingï¼š

| i | Computed Index           | èªªæ˜                |
| - | ------------------------ | ----------------- |
| 1 | (3 + 1 + 1^2) mod 10 = 5 | slot[5] ç©º â†’ æ’å…¥ 33 |

âœ… æ’å…¥æˆåŠŸ

**Table ç‹€æ…‹ï¼š**

```
slot[3] = 23
slot[5] = 33
```

---

# **Step 3: æ’å…¥ 43**

1. è¨ˆç®—åˆå§‹ indexï¼š

   ```
   h(43) = 43 mod 10 = 3
   i = 0 â†’ index = 3 (slot[3] è¢« 23 å ç”¨)
   ```
2. Collision â†’ Quadratic Probingï¼š

| i | Computed Index           | èªªæ˜                          |
| - | ------------------------ | --------------------------- |
| 1 | (3 + 1 + 1^2) mod 10 = 5 | slot[5] è¢« 33 å ç”¨ â†’ collision |
| 2 | (3 + 2 + 2^2) mod 10 = 9 | slot[9] ç©º â†’ æ’å…¥ 43           |

âœ… æ’å…¥æˆåŠŸ

**Table ç‹€æ…‹ï¼š**

```
slot[3] = 23
slot[5] = 33
slot[9] = 43
```

---

# **Observationï¼ˆè§€å¯Ÿï¼‰**

1. **Quadratic Probing çš„ gap**

   * æ¢æ¸¬é–“è·éš¨ i çš„å¹³æ–¹å¢é•· â†’ `0, 2, 6, 12â€¦` mod m
   * ä¸åƒ Linear Probing é‚£æ¨£é€£çºŒ â†’ **æ¸›å°‘ Primary Clustering**

2. **å¯èƒ½å•é¡Œ**

   * æœƒè·³éä¸€äº› slotsï¼ˆä¸ä¿è­‰æ¯å€‹ slot éƒ½æœƒè¢«æª¢æŸ¥åˆ°ï¼‰
   * å¦‚æœ table size æˆ– c1/c2 é¸å¾—ä¸åˆé©ï¼Œå¯èƒ½æ‰¾ä¸åˆ°ç©ºä½ â†’ å¿…é ˆå°å¿ƒè¨­è¨ˆ

---

# **ä¸€å¥è©±ç†è§£**

> Quadratic Probing = æ¯æ¬¡ç¢°æ’è·³åˆ°è·é›¢ **iÂ² + i** çš„ slot â†’ æ¸›å°‘é€£çºŒç¾¤èšï¼Œä½†å¯èƒ½è·³éä¸€äº›æ§½ï¼Œéœ€è¦è¨­è¨ˆåˆé©çš„ table sizeã€‚

---

# p.47 Secondary Clustering   

---

# âœ… **Secondary Clusteringï¼ˆäºŒæ¬¡ç¾¤èšï¼‰**

**å®šç¾©ï¼š**

> åœ¨ **Open Addressing Hash Table** ä¸­ï¼Œä¸åŒçš„ keys å¦‚æœ **hash åˆ°ç›¸åŒçš„åˆå§‹ indexï¼ˆh(k))**ï¼Œ
> å³ä½¿ä½¿ç”¨ Quadratic Probing æˆ–å…¶ä»–æ¢æ¸¬æ–¹æ³•ï¼Œå®ƒå€‘æœƒ **æ²¿è‘—ç›¸åŒçš„æ¢æ¸¬åºåˆ—**ï¼Œ
> å½¢æˆä¸€ç¨®ç¾¤èšï¼Œç¨±ç‚º **Secondary Clustering**ã€‚

---

# ğŸ”¹ **å…¬å¼ç¤ºæ„**

* Hash functionï¼š`h(k) = k mod 10`
* Quadratic Probingï¼š`index(i) = (h(k) + c1*i + c2*i^2) mod 10`
* c1, c2 å¸¸è¨­ç‚º 1

---

# ğŸ”¹ **å·®åˆ¥æ–¼ Primary Clustering**

| ç‰¹æ€§   | Primary Clustering              | Secondary Clustering                           |
| ---- | ------------------------------- | ---------------------------------------------- |
| ç™¼ç”ŸåŸå›  | é€£çºŒå¡«æ»¿æ§½å½¢æˆ clusterï¼ˆLinear Probingï¼‰ | ä¸åŒ key hash åˆ°åŒä¸€åˆå§‹ index â†’ probe sequence ç›¸åŒ    |
| ç¯„åœ   | æ•´å€‹ cluster                      | åªé‡å°åŒä¸€å€‹åˆå§‹ index çš„ keys                          |
| é¿å…æ–¹æ³• | Quadratic / Double Hashing      | **Double Hashing**ï¼ˆä¸åŒ key æœƒæœ‰ä¸åŒ probe sequenceï¼‰ |

---

# ğŸ”¹ **ç¤ºæ„ä¾‹å­**

å‡è¨­ï¼š

* Table size m = 10
* Quadratic Probingï¼š`index(i) = (h(k) + i + i^2) mod 10`
* æ’å…¥ keys = 23, 33, 43

1. **23 â†’ h(23)=3 â†’ slot[3] ç©º â†’ æ”¾å…¥**
2. **33 â†’ h(33)=3 â†’ collision â†’ Quadratic Probing â†’ slot[5]**
3. **43 â†’ h(43)=3 â†’ collision â†’ Quadratic Probing â†’ slot[9]**

* æ³¨æ„ï¼šæ‰€æœ‰ key çš„åˆå§‹ index éƒ½æ˜¯ 3 â†’ probe sequence ä¸€æ¨£ â†’ **secondary clustering ç™¼ç”Ÿ**

å¦‚æœä½ ç”¨ **Double Hashing**ï¼š

* probe sequence = `(h1(k) + i*h2(k)) mod m`
* ä¸åŒ key çš„ h2(k) ä¸åŒ â†’ probe sequence ä¸åŒ â†’ é¿å… secondary clustering

---

# ğŸ”¹ **ä¸€å¥è©±ç†è§£**

> **Secondary Clustering = ä¸åŒ keys åˆå§‹ hash ç›¸åŒ â†’ æ¢æ¸¬åºåˆ—ç›¸åŒ â†’ å½¢æˆå°å‹ç¾¤èšã€‚**

---

# p.48-51 Double Hashing   

---

# âœ… **Double Hashingï¼ˆé›™é›œæ¹Šï¼‰å¾©ç¿’**

Double Hashing ä½¿ç”¨å…©å€‹ hash functionï¼š

```
h1(k) = k mod 10
h2(k) = 7 âˆ’ (k mod 7)
index(i) = (h1(k) + i Ã— h2(k)) mod 10
```

* `h1(k)` æ±ºå®šåˆå§‹ä½ç½®
* `h2(k)` æ±ºå®šæ¢æ¸¬ï¼ˆè·³ä½ï¼‰è·é›¢ï¼ˆstep sizeï¼‰
* i = 0,1,2,â€¦

ç‰¹é»ï¼š

* **ä¸åŒ key â†’ é€šå¸¸æœ‰ä¸åŒçš„ h2(k)**
* æ¢æ¸¬è·¯å¾‘ï¼ˆprobe sequenceï¼‰ä¹Ÿä¸åŒ
* èƒ½é¿å… primary clustering & secondary clustering
* æ¢æ¸¬åˆ†å¸ƒã€Œæœ€å‡å‹»ã€çš„ open addressing æ–¹æ³•

---

# ğŸš€ **é–‹å§‹æ’å…¥ï¼š23ã€33ã€43**

Table å¤§å° = 10ï¼ˆslot 0~9ï¼‰

---

# â­ Step 1ï¼šæ’å…¥ 23

### è¨ˆç®— h1, h2

```
h1(23) = 23 mod 10 = 3
h2(23) = 7 â€“ (23 mod 7) = 7 â€“ 2 = 5
```

### æ¢æ¸¬åºåˆ—

`index(i) = (3 + i Ã— 5) mod 10`

| i | index(i)           | Result           |
| - | ------------------ | ---------------- |
| 0 | (3 + 0) mod 10 = 3 | slot[3] ç©º â†’ æ’å…¥æˆåŠŸ |

ğŸ“Œ **çµæœï¼šslot[3] = 23**

---

# â­ Step 2ï¼šæ’å…¥ 33

### è¨ˆç®— h1, h2

```
h1(33) = 3
h2(33) = 7 â€“ (33 mod 7) = 7 â€“ 5 = 2
```

### æ¢æ¸¬åºåˆ—

`index(i) = (3 + i Ã— 2) mod 10`

| i | index(i)           | Result                     |
| - | ------------------ | -------------------------- |
| 0 | (3 + 0) mod 10 = 3 | slot[3] è¢« 23 å ç”¨ï¼ˆcollisionï¼‰ |
| 1 | (3 + 2) mod 10 = 5 | slot[5] ç©º â†’ æ’å…¥æˆåŠŸ           |

ğŸ“Œ **çµæœï¼šslot[5] = 33**

---

# â­ Step 3ï¼šæ’å…¥ 43

### è¨ˆç®— h1, h2

```
h1(43) = 3
h2(43) = 7 â€“ (43 mod 7) = 7 â€“ 1 = 6
```

### æ¢æ¸¬åºåˆ—

`index(i) = (3 + i Ã— 6) mod 10`

| i | index(i)           | Result           |
| - | ------------------ | ---------------- |
| 0 | (3 + 0) mod 10 = 3 | slot[3] è¢« 23 å ç”¨  |
| 1 | (3 + 6) mod 10 = 9 | slot[9] ç©º â†’ æ’å…¥æˆåŠŸ |

ğŸ“Œ **çµæœï¼šslot[9] = 43**

---

# ğŸ§Š æœ€å¾Œçš„ Hash Table

| Slot | Value |
| ---- | ----- |
| 3    | 23    |
| 5    | 33    |
| 9    | 43    |

---

# ğŸ¯ Observationï¼ˆä½ åŸæœ¬è¬›ç¾©æœ€å¾Œé‚£å¥ï¼‰

### **Double Hashing çš„ç‰¹æ€§ï¼š**

* æ¢æ¸¬è·³è·ï¼ˆstep sizeï¼‰ä¾†è‡ªç¬¬äºŒå€‹ hash function â†’ **åˆ†å¸ƒå¾ˆå¥½ã€è·³å¾—é **
* ä¸æœƒå½¢æˆ primary clusteringï¼ˆåƒ Linear Probing é‚£æ¨£ï¼‰
* ä¸æœƒå½¢æˆ secondary clusteringï¼ˆåƒ Quadratic Probing é‚£æ¨£ï¼‰
* æ’å…¥ã€æœå°‹æ•ˆç‡åœ¨ load factor é«˜æ™‚ä»ç„¶å¾ˆå¥½

ğŸ‘‰ **æ‰€æœ‰ open addressing è£¡ï¼Œdouble hashing æ•ˆèƒ½æœ€å¥½ï¼Œä¹Ÿæœ€æ¥è¿‘ uniform random probingã€‚**

---

# æ¯”è¼ƒ   

| æ–¹æ³•                    | Probe å…¬å¼                             | å„ªé»                    | ç¼ºé»                   | æœƒç”¢ç”Ÿçš„ Clustering                          |
| --------------------- | ------------------------------------ | --------------------- | -------------------- | ---------------------------------------- |
| **Linear Probing**    | index(i) = (h(k) + i) mod m          | ç°¡å–®ã€å¿«                  | å®¹æ˜“å½¢æˆé•·é•·çš„é€£çºŒç¾¤é›†          | **Primary Clustering**ï¼ˆåš´é‡ï¼‰               |
| **Quadratic Probing** | index(i) = (h(k) + câ‚i + câ‚‚iÂ²) mod m | æ¸›å°‘ primary clustering | å¯èƒ½ç„¡æ³•æ¢è¨ªåˆ°æ‰€æœ‰ slotã€éœ€ç²¾é¸ m | **Secondary Clustering**ï¼ˆä»å­˜åœ¨ï¼‰            |
| **Double Hashing**    | index(i) = (hâ‚(k) + iÂ·hâ‚‚(k)) mod m   | åˆ†å¸ƒæœ€å‡å‹»ã€æ¢æŸ¥è·¯å¾‘å¤šæ¨£          | éœ€è¦å…©å€‹å¥½çš„ hash å‡½æ•¸       | **æœ€å°‘ Clustering**ï¼ˆç„¡ primary & secondaryï¼‰ |

---

# p.59 ADT: Dictionary

## 1ï¸âƒ£ objectsï¼ˆè³‡æ–™å…§å®¹ï¼‰

```
A collection of n > 0 pairs,
each pair has a key and an associated item
```

æ„æ€æ˜¯ï¼š

* Dictionary è£¡æœ‰ **n å€‹ (key, item) é…å°**

ä¾‹å¦‚ï¼š

```
(A, 10), (B, 20), (C, 30)
```

ğŸ“Œ **key**ï¼šç”¨ä¾†æ‰¾è³‡æ–™
ğŸ“Œ **item**ï¼šçœŸæ­£å­˜çš„è³‡æ–™

## 2ï¸âƒ£ functionsï¼ˆå¯ä»¥åšçš„æ“ä½œï¼‰

### ğŸ”¹ Create

```
Dictionary Create(max_size)
::= create an empty dictionary.
```

ğŸ‘‰ å»ºç«‹ä¸€å€‹**ç©ºçš„ dictionary**

* `max_size`ï¼šæœ€å¤šå¯ä»¥å­˜å¹¾å€‹ pair
* ä¸€é–‹å§‹æ˜¯ **æ²’æœ‰ä»»ä½•è³‡æ–™**

---

### ğŸ”¹ IsEmpty

```
Boolean IsEmpty(d, n)
::= if (n > 0) return TRUE
    else return FALSE
```

ğŸ‘‰ æª¢æŸ¥ dictionary æ˜¯ä¸æ˜¯ç©ºçš„

ğŸ“Œ ç™½è©±æ„æ€ï¼š

* å¦‚æœå…ƒç´ æ•¸é‡ `n > 0` â†’ **ä¸æ˜¯ç©ºçš„**
* å¦‚æœ `n = 0` â†’ **æ˜¯ç©ºçš„**

âš ï¸ æŠ•å½±ç‰‡é€™è£¡å¯«æ³•æœ‰é»æ€ª
æ¯”è¼ƒåˆç†çš„èªæ„æ‡‰è©²æ˜¯ï¼š

```
if (n == 0) return TRUE
else return FALSE
```

è€ƒè©¦æ™‚çŸ¥é“å®ƒæ˜¯åœ¨ã€Œæª¢æŸ¥æ˜¯å¦ç‚ºç©ºã€å°±å¥½ã€‚

---

### ğŸ”¹ Search

```
Element Search(d, k)
::= return item with key k.
    return NULL if no such element.
```

ğŸ‘‰ ç”¨ **key k** æ‰¾å°æ‡‰çš„ **item**

* æ‰¾å¾—åˆ° â†’ å›å‚³ item
* æ‰¾ä¸åˆ° â†’ å›å‚³ `NULL`

ğŸ“Œ Dictionary æœ€é‡è¦çš„åŠŸèƒ½ â­â­â­

---

### ğŸ”¹ Delete

```
Element Delete(d, k)
::= delete and return item (if any) with key k.
```

ğŸ‘‰ åˆªæ‰ key = k çš„é‚£ä¸€å°è³‡æ–™

* å¦‚æœå­˜åœ¨ â†’ åˆªæ‰ä¸¦å›å‚³ item
* å¦‚æœä¸å­˜åœ¨ â†’ ä»€éº¼éƒ½ä¸åˆªï¼ˆå¯èƒ½å› NULLï¼‰

---

### ğŸ”¹ Insert

```
void Insert(d, item, k)
::= insert item with key k into d.
```

ğŸ‘‰ æ’å…¥ä¸€ç­†æ–°è³‡æ–™ `(k, item)`

ğŸ“Œ éš±å«è¦å‰‡ï¼ˆè€å¸«å¸¸è€ƒï¼‰ï¼š

* **key ä¸å¯é‡è¤‡**
* è‹¥ key å·²å­˜åœ¨ï¼š

  * å¯èƒ½è¦†è“‹èˆŠè³‡æ–™
  * æˆ–æ‹’çµ•æ’å…¥ï¼ˆçœ‹å¯¦ä½œï¼‰

---

## 3ï¸âƒ£ ç”¨ä¸€å€‹å®Œæ•´ä¾‹å­ä¸²èµ·ä¾†

```
d = Create(100)
IsEmpty(d) â†’ TRUE

Insert(d, "Alice", 1001)
Insert(d, "Bob",   1002)

Search(d, 1001) â†’ "Alice"
Delete(d, 1002) â†’ "Bob"
Search(d, 1002) â†’ NULL
```

## 4ï¸âƒ£ ä¸€å¼µè€ƒè©¦é€Ÿè¨˜è¡¨ âœ…

| Operation | åŠŸèƒ½             |
| --------- | -------------- |
| Create    | å»ºç«‹ç©º dictionary |
| IsEmpty   | æ˜¯å¦æ²’æœ‰è³‡æ–™         |
| Insert    | æ’å…¥ (key, item) |
| Search    | ç”¨ key æ‰¾ item   |
| Delete    | åˆªé™¤æŒ‡å®š key       |

---

# p.60 ADT: HashTable with Separate Chaining   

---

# âœ… **ADT: HashTable with Separate Chainingï¼ˆæ‹‰éŠæ³•é›œæ¹Šè¡¨ï¼‰**

### **ç‰©ä»¶ï¼ˆobjectsï¼‰**

HashTable å…§éƒ¨åŒ…å«ï¼š

* ä¸€çµ„ **key-value pair**ï¼ˆéµå”¯ä¸€ï¼‰
* ä¸€å€‹å¤§å°ç‚º **m** çš„ bucket é™£åˆ—
  æ¯å€‹ bucket æ˜¯ **ä¸€æ¢ linked listï¼ˆchainï¼‰**ï¼Œè£¡é¢å­˜å¤šå€‹ `<key, value>`ã€‚

### **é›œæ¹Šæ–¹å¼**

ä½¿ç”¨é›œæ¹Šå‡½å¼ï¼š

```
h(key) â†’ [0, m-1]   // å° key åš hashï¼Œæ±ºå®šå®ƒå±¬æ–¼å“ªå€‹ bucket
```

---

# ğŸ¯ **åƒæ•¸ï¼ˆparametersï¼‰**

| åç¨±                | æ„ç¾©                              |
| ----------------- | ------------------------------- |
| `m`               | bucket æ•¸é‡                       |
| `h`               | hash functionï¼ˆå›ºå®šã€å¯é‡è¤‡ã€åˆ†å¸ƒå‡å‹»ï¼‰      |
| `Î» = n / m`       | load factorï¼ˆå¹³å‡æ¯å€‹ bucket è£¡æœ‰å¤šå°‘å…ƒç´ ï¼‰ |
| `MAX_LOAD_FACTOR` | é€šå¸¸è¨­ 0.75ï¼Œè¶…éå°±æ“´å¢                  |

---

# ğŸ§± **æ–¹æ³•ï¼ˆoperations / functionsï¼‰**

---

## âœ” **Create(m)**

**å‰ç½®æ¢ä»¶ï¼ˆpreconditionï¼‰ï¼š**

```
m > 0
```

**å¾Œç½®æ¢ä»¶ï¼ˆpostconditionï¼‰ï¼š**

```
å»ºç«‹ä¸€å€‹ m å€‹ç©º bucket çš„ hash table
æ‰€æœ‰ bucket éƒ½æ˜¯ç©ºçš„ chain
Î» = 0
```

---

## âœ” **IsEmpty(h)**

å›å‚³ï¼ˆTRUE / FALSEï¼‰ï¼š

```
size(h) == 0
```

---

## âœ” **Insert(h, k, v)**

```
i = h(k) mod m    // æ‰¾ bucket index
```

1. è‹¥ bucket[i] è£¡å·²å­˜åœ¨ key kï¼š
   â†’ **æ›´æ–° value ç‚º vï¼ˆå–ä»£èˆŠå€¼ï¼‰**

2. å¦å‰‡ï¼š
   â†’ **æŠŠ <k, v> æ’å…¥åˆ° bucket[i] çš„éˆçµä¸²åˆ—ã€Œé–‹é ­ã€**
   â†’ size++

3. è‹¥ Î» > MAX_LOAD_FACTORï¼š
   â†’ åŸ·è¡Œ `Resize(h, 2*m)`ï¼ˆé‡æ–°åˆ†é…æ‰€æœ‰ keyï¼‰

---

## âœ” **Retrieve(h, k)**

```
i = h(k) mod m
åˆ° bucket[i] è£¡æ‰¾ key k
```

* è‹¥æ‰¾åˆ°ï¼šå›å‚³å°æ‡‰ value
* è‹¥æ‰¾ä¸åˆ°ï¼šä¸Ÿå‡º `KeyNotFoundException`

---

## âœ” **Delete(h, k)**

```
i = h(k) mod m
```

* è‹¥ bucket[i] è£¡æœ‰ kï¼š
  â†’ åˆªé™¤ `<k, v>`
  â†’ size--
  â†’ å›å‚³ TRUE
* è‹¥æ²’æœ‰ï¼š
  â†’ å›å‚³ FALSE

---

## âœ” **Search(h, k)**

```
i = h(k) mod m
å›å‚³ (bucket[i] æ˜¯å¦å« key k)
```

---

## âœ” **Traverse(h)**

å›å‚³ä¸€å€‹ iteratorï¼Œé †åºç‚ºï¼š

1. bucket[0]
2. bucket[1]
3. ...
4. bucket[m-1]

åœ¨æ¯å€‹ bucket è£¡ï¼Œä¾ **æ’å…¥é †åº** èµ°è¨ªæ‰€æœ‰ pairã€‚

---

# ğŸ‰ **å®Œæ•´ ADTï¼ˆæ¼‚äº®æ ¼å¼ï¼‰**

```
ADT HashTable is
objects:
    A finite set of <key, value> pairs with unique keys.
    Keys are distributed into m buckets by hash function:
        h(key) â†’ [0, m-1].
    Each bucket contains a chain (linked list) of pairs.

parameters:
    m: number of buckets (m > 0)
    h: deterministic hash function
    Î»: load factor = n / m
    MAX_LOAD_FACTOR = 0.75

operations:

HashTable Create(m)
    pre:  m > 0
    post: return empty table with m buckets and Î» = 0

Boolean IsEmpty(h)
    return (size(h) == 0)

Insert(h, k, v)
    i = h(k) mod m
    if k exists in bucket[i]:
        replace existing value with v
    else:
        insert <k, v> at front of bucket[i]
        size++
    if Î» > MAX_LOAD_FACTOR:
        Resize(h, 2*m)

value Retrieve(h, k)
    i = h(k) mod m
    search bucket[i] for k
    if found: return associated value
    else: throw KeyNotFoundException

Boolean Delete(h, k)
    i = h(k) mod m
    if k exists in bucket[i]:
        remove <k, v>
        size--
        return TRUE
    else:
        return FALSE

Boolean Search(h, k)
    i = h(k) mod m
    return (k exists in bucket[i])

Iterator Traverse(h)
    return iterator visiting buckets from 0 to m-1,
    and within each bucket in insertion order

end HashTable
```
