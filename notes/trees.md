# p.10、p.14 名詞解釋   

* root：最上面的節點
* interval：必有一個以上的children 
* leaf：沒有 child
* parent, child
* siblings：同一個 parent 的 children
* edge：節點的連線
* subtree：子樹(有parent跟child)
* level：在哪一層(0~n)
* depth / height：深度、樹的高度
* fan-out / degree：一個節點最多可以有幾個 child
  * Binary Tree（二元樹）
    degree = 2 每個節點最多兩個 child）
  * Trie（字典樹）
    degree = 字母數量（英文可能 26，小寫英文字母就是 26）
  * B-tree、B+ tree（資料庫用）
    degree 可以大到上百 → 這能讓資料庫查詢 super 快
go out    stay home

---

# p.15

### 🌟 1. **Full Binary Tree（滿二元樹）

每個節點 **要嘛有 2 個孩子，要嘛 0 個（是 leaf）**。

> **不能只有 1 個 child。**

可以把它想像成「完全整齊的二元分支」：

```
       A
     /   \
    B     C
   / \   / \
  D  E  F  G
```

💡 用在：

* **機器學習（ML）決策點**
  每一個 node 做兩種分支選擇：yes/no、true/false

---

### 🌟 2. **Complete Binary Tree（完全二元樹）**

樹的每一層都要填滿，**只有最後一層可以沒滿，但一定要從左邊開始填。**

想像你排座位，最後一排可以沒坐滿，但不能中間空一格。

```
       A
     /   \
    B     C
   / \
  D   E
```

💡 用在：

* **Heap（堆積樹）**
  → 優先隊列 priority queue 就是用 heap
  → heap 必須是 complete 才能用 array 表示

---

### 🌟 3. **Binary Search Tree（BST）**

有排序規則的二元樹：

> **左 < 根 < 右**

看起來像：

```
       50
     /     \
   30       70
  /  \     /  \
20  40   60  80
```

💡 用在：

* O(log n) 搜尋（如果樹平衡）
* 重要資料結構：set、map（底層常用平衡 BST）

---

### 🌟 4. **Balanced Tree（平衡樹：如 AVL、Red-Black）**

保持樹的高度差不會太大的樹。
否則 BST 會退化成 linked list。

不平衡長這樣：

```
1
 \
  2
   \
    3
     \
      4
```

平衡樹會自動旋轉成高度差小的樣子。

💡 用在：

* **C++ STL 的 map / set** → Red-Black Tree
* **Java TreeMap**
* **Linux Kernel** 也用 R-B Tree

---

### 🌟 5. **General Tree（多叉樹，無限制）**

節點可以有任意多個孩子。
不像二元樹只有 left/right。

想像檔案系統：

```
Folder
├── A
├── B
└── C
    ├── C1
    └── C2
```

💡 用在：

* **檔案系統（File System）**
* **XML / HTML / JSON**
* **組織架構（Org Chart）**

---

### 🌟 6. **N-ary Tree（N 叉樹）**

General tree 的限制版：
**每個節點最多可以有 N 個 child。**

例如 N = 3：

```
     A
   / | \
  B  C  D
```

💡 用在：

* **遊戲 AI 決策樹**
  → 下棋時每個 state 有很多可能動作
  → 每個節點分支數有限（N）

---

### 🌟 7. **Trie（Prefix Tree，字典樹）**

用字母一個一個往下走的樹。

例如加入單字「cat」和「car」：

```
     c
     |
     a
   /   \
  t     r
```

🧠 優點

* 查找字串超快 → O(length)
* 不需要比較整個字串

💡 用在：

* **Auto-complete（輸入法）**
* **字典、搜尋引擎**
* **Google 搜尋建議**

---

### 🌟 8. **Decision Tree（決策樹）**

機器學習（ML）用的樹，每個節點是「一個問題」，分支是答案。

例如：

```
Is weather sunny?
  /         \
yes         no
|           |
go out    stay home
```

💡 用在：

* **機器學習分類**
* **信用評估（借不借錢）**
* **醫療診斷（有沒有病）**

---

### 🌟 9. **Abstract Syntax Tree（AST）**

程式碼 → 編譯器要把它拆成樹狀表示語法。

例如程式碼：

```
3 + 4 * 5
```

AST 會變成：

```
     +
   /   \
  3     *
       / \
      4   5
```

💡 用在：

* **編譯器（Compiler）**
* **程式分析工具**
* **IDE 語法高亮、錯誤提示**

---

### 🌟 10. **Spanning Tree（生成樹）**

圖（graph）的一個子集合：

> **用最少的邊，把所有節點連起來，而且不能有環。**

像把所有城市連成「一張最便宜的網路」。

想像城市道路：

城市 A—B—C—D
用最少的路連起來不重複。

💡 用在：

* **網路路由（routing）**
* **最小生成樹（MST）**
* **Kruskal / Prim 演算法**

---

# 🎉 最後做一張總整理（超清楚記憶版）

| Tree Type       | 特色                  | 用途                    |
| --------------- | ------------------- | --------------------- |
| Full Binary     | 0 或 2 child         | ML decision structure |
| Complete Binary | 除最後層外都滿             | Heap                  |
| BST             | Left < Root < Right | Searching, Sorting    |
| Balanced Tree   | 高度維持小               | set/map               |
| General Tree    | 任意 child            | File system, JSON     |
| N-ary Tree      | ≤ N child           | Game AI               |
| Trie            | 字母分支                | auto-complete         |
| Decision Tree   | 問題→判斷               | ML classification     |
| AST             | 語法樹                 | 編譯器                   |
| Spanning Tree   | 最少邊連全部節點            | Routing, MST          |

---

# p.15 補充4、8、10 + 1、2 比較   

### 🍀 **(4) Balanced Tree（平衡樹）— 超詳細解說**

Balanced Tree 是所有資料結構裡「最重要」也「最常考」的概念之一。

---

🌳 **Balanced Tree 是什麼？**

> **Balanced Tree = 保持高度不會歪掉的樹**

就這麼簡單！

但為什麼重要？
因為如果樹歪掉（skewed），搜尋速度會變得非常慢：

如果樹長這樣（像 Linked List）👇

```
1
 \
  2
   \
    3
     \
      4
```

搜尋變成 **O(n)**（慢到爆），等於 Linked List。

---

🌲 **Balanced Tree 一定長得像「金字塔」這樣👇**

```
        8
      /   \
     4     12
    / \   /  \
   2   6 10  14
```

**根本看起來就很「平均」**
→ 搜尋速度 = O(log n)（快很多）
→ 資料結構裡的「快」其實都是靠它

---

🧠 **什麼是“平衡”？（真正的定義）**

每種平衡樹的規則不同，但目標一樣：

> **讓左右子樹高度差保持在可控制範圍內。**

例如：

⭐ AVL Tree：

> 每個節點左、右子樹高度差 ≤ 1

超嚴格 → 平衡度最好 → 搜尋最快
但插入、刪除需要旋轉（旋很多）

⭐ Red-Black Tree：

> 用「顏色」規則讓樹不會過度偏移
> 高度維持 O(log n)

較寬鬆 → 插入刪除效率比較好
用得超廣：

* C++ map, set
* Java TreeMap
* Linux Kernel

---

🔧 **Balanced Tree 的用途（超多）：**

* 高效搜尋（set / map）
* 高效插入刪除
* 資料庫索引（紅黑樹）
* 記憶體管理（Kernel）
* GIS、查詢引擎等

👉 **凡是需要大量搜尋 + 維持順序的地方，都會用 Balanced Tree。**

---

### 🍀 **(8) Decision Tree（決策樹）— 超詳細解說**

Decision Tree 是 **機器學習（ML）裡最直覺的模型**。

不像神經網路很抽象，決策樹超好懂。

---

🌳 **Decision Tree 是什麼？**

> **每個節點是「一個問題」，每個分支是「答案」，最後的葉節點是結果。**

就是一棵「問答流程樹」。

---

**舉例：你要不要出門？**

```
           Is it sunny?
          /            \
       Yes              No
      /                  \
Is it weekend?       Stay home
   /     \
 Yes      No
/           \
Go out     Stay home
```

每個 node 就是一個「判斷」。
路徑 = 一串決策。

---

📘 **Decision Tree 如何用在機器學習？**

例如：要不要核貸（給你貸款）

```
    Income > 30k?
      /        \
    Yes        No
    /            \
Credit Good?     Reject
  /    \
Yes     No
 |       \
Approve  Reject
```

模型訓練時會自動「找最佳問題」來分資料。

---

⭐ **Decision Tree 的優點：**

* 超直覺
* 很容易視覺化
* 不需要標準化資料
* 能處理數字 & 類別

---

⚠️ **缺點：**

* **容易過擬合（overfitting）**
* 小資料變化 → 樹形狀完全變掉

所以才有：

* **Random Forest**（多棵決策樹）
* **XGBoost**（超強的樹集成方法）

你聽過的 Kaggle 冠軍模型幾乎都跟 Decision Trees 有關。

---

### 🍀 **(10) Spanning Tree（生成樹）— 超詳細解說**

Spanning Tree 是 **圖論（graph theory）** 裡的重要概念。

---

🌳 **Spanning Tree 是什麼？**

> **在一張圖裡，挑一些邊，讓所有節點互相可以到達，而且不能有環。**

就像要蓋一個能連所有城市的路網，但路要「最簡單，不能重複」。

---

看圖理解最清楚：

原本圖（含環）：

```
A — B — C
|   |   |
D — E — F
```

Spanning Tree 會變成：

```
A — B — C
     |    
     E — F
     |
     D
```

所有點都會被連起來，但是：

* 沒有環
* 路數剛剛好

---

⭐ Spanning Tree 一定具有：

* **包含所有節點**
* **邊數 = 節點數 − 1**
* **不能有 cycle**

---

🥇 **最有名的：Minimum Spanning Tree（最小生成樹 MST）**

要找出「連所有節點最便宜的網路」。

多用：

* **Kruskal 演算法**
* **Prim 演算法**

---

💡 Spanning Tree 的用途多到爆：

* 網路設計（Router、Switch）
* 設計高速公路、光纖架構
* 電力網路
* Cluster 用的 minimum spanning tree
* 圖論演算法基本功

---

### 🌈 **Part 2：Full Binary Tree vs Complete Binary Tree 差在哪？**

你問：

> 1. Full Binary Tree
> 2. Complete Binary Tree
>    **有差嗎？**

差很多！！
這兩個是不同概念，不能混用。

---

### 🌳 **(1) Full Binary Tree = 每個節點 0 或 2 子節點**

不能有 1 個 child 的節點！

```
    A
   / \
  B   C
```

但這樣就不符合：

```
   A
  / 
 B   ← ❌ 只有一個 child
```

**這不叫 full。**

---

### 🌳 **(2) Complete Binary Tree = 層層填滿，最後一層可部分缺，但一定從左邊開始放note**

舉例：

```
       A
     /   \
    B     C
   / \
  D   E
```

這是 complete。

但下面這樣不是：

```
     A
   /   \
  B     C
       /
      D
```

最後一層缺口不能在中間。

---

### 🎯 **差異一覽表**

| 類別          | Full Binary Tree    | Complete Binary Tree |
| ----------- | ------------------- | -------------------- |
| 設定          | 每個節點 0 或 2 children | 除最後層外都要滿，最後層從左填      |
| 可否有 1 child | ❌ 不可                | ✔️ 可以                |
| 必須滿嗎？       | ❌ 不必每層都滿            | ✔️ 幾乎都滿              |
| 應用          | ML decision nodes   | Heap、priority queue  |
| 形狀限制        | 結構嚴格，但自由度較大         | 結構接近滿樹（很整齊）          |

---

### 🎉總結一句話：

> **Full = 每個節點不是 0 就是 2 child（左右都有）**
> **Complete = 樹形狀超整齊（像滿樹，但最後一層可缺）**

兩者差非常多。

---

# p.16

# (1) B-Tree / B+ Tree

**參考網站1：https://vocus.cc/article/6720dd18fd89780001dae749**   
**參考網站2：https://ithelp.ithome.com.tw/articles/10333181**

這兩種樹的目標都是透過「矮胖」的結構（讓每個節點可以放很多鍵值），來**最小化磁碟 I/O 次數**，從而提高搜尋速度。

## 🎯 B 樹 與 B+ 樹 的三大關鍵差異

下表總結了它們在結構、資料儲存和查詢效率上的主要不同點：

| 特性 | 🌳 B 樹 (B-Tree) | 🌲 B+ 樹 (B+ Tree) |
| :--- | :--- | :--- |
| **資料儲存位置** | **內部節點**和**葉節點**都可能儲存**實際資料 (Data)**。 | **只有葉節點**才儲存**實際資料 (Data)**。內部節點僅儲存**索引 (Keys)**。 |
| **內部節點作用** | 既是**索引**，也可能包含**資料**。 | **純粹的索引**和**導航**作用。 |
| **葉節點串聯** | **沒有**特殊的指針串聯。 | **所有葉節點**會用**鏈結串列**串起來 (像串珠一樣)。 |

### 1. 📂 儲存結構差異 (決定了 I/O 效率)

這是 B 樹與 B+ 樹 **最核心的差異**：

* **B 樹:** 每個內部節點 $\rightarrow$ **鍵值 + 資料**。
* **B+ 樹:** 內部節點 $\rightarrow$ **只有鍵值**；葉節點 $\rightarrow$ **鍵值 + 資料**。 

#### **為什麼 B+ 樹的設計更好？**

1.  **容納更多鍵值 (Higher Fan-out):**
    * 由於 B+ 樹的**內部節點**不儲存實際資料，同樣大小的一個磁碟區塊（例如 4KB）就可以容納**更多索引鍵 (Keys)**。
    * 每個內部節點能指向更多的子節點，這使得樹的**分支出更多**，樹的**高度更低**。
    * **樹越矮** $\rightarrow$ **查詢所需的磁碟 I/O 次數越少** $\rightarrow$ **查詢速度越快**。

2.  **查詢效率穩定 (Consistent Search Time):**
    * B 樹可能在內部節點就找到資料並停止搜尋（提早退出）。
    * B+ 樹則**保證**每次查詢都必須從根節點走到**葉節點**才能取到資料。
    * 雖然 B+ 樹的步數可能是固定且較長的，但由於它的樹高很低且固定，因此在**最壞情況下和平均情況下的查詢效率都非常穩定且高效**，這對資料庫系統非常重要。

### 2. 🔗 範圍查詢差異 (決定了應用場景)

* **B+ 樹:**
    * 葉節點之間是用**單向或雙向鏈結串列**串聯起來的。
    * 進行**範圍查詢**（例如：找出所有分數在 60 到 80 之間的學生），只需要先找到 **60** 這個鍵值的葉節點，然後沿著鏈結串列順序遍歷到 **80** 所在的葉節點即可。這種**順序掃描 (Sequential Scan)** 效率極高，因為它非常適合磁碟的**連續讀取**模式。
* **B 樹:**
    * 如果要在 B 樹中進行範圍查詢，必須對樹做複雜的**中序遍歷 (In-order Traversal)**，這涉及到多次**非連續的 I/O 跳轉**，效率遠低於 B+ 樹。

### 結論

正因為 B+ 樹具有**高度更低 (更少的 I/O)** 和**極為高效的範圍掃描能力**，所以現代的**資料庫系統 (如 MySQL 的 InnoDB)** 和**檔案系統**幾乎都採用 **B+ 樹** 作為索引結構。

---

# (2) Segment Tree (線段樹) 

Segment Tree (線段樹) 的每個節點儲存的內容**不是固定的**，它取決於您設計這棵樹是為了解決哪種**區間查詢 (Range Query)** 問題。

* **核心原則：** 每個節點儲存的資訊，必須是能夠將其**兩個子節點的資訊合併 (Merge)** 後得到的結果。

🔍 線段樹節點儲存的內容

線段樹的每個節點代表陣列中的一個**連續區間**。節點中儲存的資料就是這個區間的**聚合值 (Aggregate Value)**。

**1. 儲存「區間和」 (Sum)**

這是線段樹最常見的應用。

* **節點內容:** 儲存該區間內所有數字的**總和 (Sum)**。
* **合併操作:** 父節點的 $\text{Sum}$ = 左子節點的 $\text{Sum}$ + 右子節點的 $\text{Sum}$。
* **應用:** 快速查詢陣列中 $L$ 到 $R$ 區間的總和。

**2. 儲存「區間最大值」 (Max)**

* **節點內容:** 儲存該區間內所有數字的**最大值 (Max Value)**。
* **合併操作:** 父節點的 $\text{Max}$ = $\text{Max}(\text{左子節點的 Max}, \text{右子節點的 Max})$。
* **應用:** 快速查詢陣列中 $L$ 到 $R$ 區間的最大值。

**3. 儲存「區間最小值」 (Min)**

* **節點內容:** 儲存該區間內所有數字的**最小值 (Min Value)**。
* **合併操作:** 父節點的 $\text{Min}$ = $\text{Min}(\text{左子節點的 Min}, \text{右子節點的 Min})$。
* **應用:** 快速查詢陣列中 $L$ 到 $R$ 區間的最小值。

### 🎯 結論：是否「同時」儲存？

是的，可以**讓線段樹的每個節點同時儲存 Sum + Max + Min**。

* 當您建立線段樹時，您可以定義節點結構為一個包含三個欄位的物件（`struct Node { sum, max, min; }`）。
* 在建樹和更新時，您需要同時計算並更新這三個值。

例如，對於一個區間 $[i, j]$ 的父節點，它的值會這樣計算：

* $\text{Parent.sum} = \text{Left.sum} + \text{Right.sum}$
* $\text{Parent.max} = \text{Max}(\text{Left.max}, \text{Right.max})$
* $\text{Parent.min} = \text{Min}(\text{Left.min}, \text{Right.min})$

這樣設計的好處是，您只需要一棵樹，就能同時支援三種不同的區間查詢，但代價是**每個節點會佔用更多的記憶體**。

### ⚠️ 重要的前提：可合併性 (Associative Property)

線段樹的基礎是建立在所儲存的聚合值必須滿足**結合律**（例如 $A+(B+C) = (A+B)+C$ 或 $\text{Max}(A, \text{Max}(B, C)) = \text{Max}(\text{Max}(A, B), C)$），這樣才能從子區間的結果正確地計算出父區間的結果。Sum、Max、Min都滿足這個條件。

---

# (3) Fenwick tree(樹狀陣列)

好的！Fenwick Tree（費氏樹），也稱為 **Binary Indexed Tree (BIT) 樹狀陣列**，是解決**前綴和 (Prefix Sum)** 查詢和**單點更新**問題的**高效**資料結構。

雖然名字裡有「樹」，但它在程式碼中其實是使用**陣列**來實現的，這就是為什麼它被稱為**樹狀陣列**。

我會用最簡單的方式，分三個部分來解釋它：**目的**、**核心原理**（位元運算）和**操作**。

## 🚀 一、 Fenwick Tree (樹狀陣列) 的目的

想像您有一個陣列 $A$，您需要頻繁地進行以下兩種操作：

1.  **查詢 (Query):** 快速計算陣列中**前 $i$ 個元素**的總和（即 $\text{Sum}[1 \dots i]$）。
2.  **更新 (Update):** 修改陣列中**單個元素** $A[k]$ 的值。

| 結構 | 查詢 $\text{Sum}[1 \dots i]$ | 更新 $A[k]$ |
| :--- | :--- | :--- |
| **簡單陣列** | $O(i)$ | $O(1)$ |
| **前綴和陣列** | $O(1)$ | $O(n)$ (需更新所有後續元素) |
| **Fenwick Tree** | **$O(\log n)$** | **$O(\log n)$** |

Fenwick Tree 的優勢在於：它能讓這兩種操作都達到 **$O(\log n)$** 的高效時間複雜度。

## 🌳 二、 Fen Fenwick Tree 的核心原理：層次化管理

Fenwick Tree 的巧妙之處在於它不直接儲存原始資料 $A[i]$，而是儲存一組特殊的**區間和**。

### 核心設計理念：

樹狀陣列 $T$ 中的每一個元素 $T[i]$ 儲存的是**原陣列 $A$ 中某一個長度的區間和**。這個區間的長度（即 $T[i]$ 負責管理多少個 $A$ 中的元素）是由 $i$ 的**二進位表示**決定的。

這個長度公式是：
$$\text{Length} = i \text{ 的二進位表示中，最右邊那個 } 1 \text{ 所代表的值}$$

例如，對於 $i=12$：

| 索引 $i$ | 二進位表示 | 最右邊的 1 (lowbit) | $T[i]$ 儲存的區間 |
| :--- | :--- | :--- | :--- |
| 12 | $1100_2$ | $4 (100_2)$ | $A[9] + A[10] + A[11] + A[12]$ |
| 13 | $1101_2$ | $1 (001_2)$ | $A[13]$ |
| 16 | $10000_2$ | $16 (10000_2)$ | $A[1] + \dots + A[16]$ |

### 🔍 關鍵：Lowbit 運算

我們需要一個數學方法來快速找到這個長度，這就是 **Lowbit 運算**：

**lowbit(i) = i & (-i)**

* & 是**位元 AND 運算**。
* $-i$ 在電腦中是 $i$ 的**二補數**。
* 這個運算會剛好得到 $i$ **最右邊的 1** 以及它後面的所有 0 所組成的數值。

#### 舉例：計算 $\text{lowbit}(12)$
1.  $i = 12 \rightarrow 0000\dots1100$
2.  $-i = -12 \rightarrow 1111\dots0100$ (二補數表示)
3.  lowbit(12) = 12 & (-12) = 0000...0100 = 4

所以 $T[12]$ 儲存的是長度為 4 的區間和： $[12 - 4 + 1, \ 12] = [9, 12]$ 的總和。

## 💻 三、 Fenwick Tree 的核心操作

### 1. 查詢前綴和 $\text{Sum}[1 \dots i]$ (Query)

我們想要找到 $\text{Sum}[1 \dots i]$。我們不需要遍歷所有元素，只需要不斷地利用 $T$ 陣列中儲存的區間和來「拼湊」出這個總和。

**步驟:**
1.  從 $i$ 開始，將 $T[i]$ 的值加入總和。
2.  更新 $i$ 到下一個需要查詢的區間起點： $i = i - \text{lowbit}(i)$。
3.  重複此過程直到 $i=0$。

**範例：查詢 $\text{Sum}[1 \dots 12]$**

| $i$ | $\text{lowbit}(i)$ | $T[i]$ 覆蓋的區間 | 累積和 | 下一個 $i$ |
| :--- | :--- | :--- | :--- | :--- |
| 12 | 4 | $[9, 12]$ | $\text{Sum} = T[12]$ | $12 - 4 = 8$ |
| 8 | 8 | $[1, 8]$ | $\text{Sum} = T[12] + T[8]$ | $8 - 8 = 0$ |
| 0 | - | - | 總和結束 | - |

$\text{Sum}[1 \dots 12]$ 就是 $T[12]$ 覆蓋的區間和與 $T[8]$ 覆蓋的區間和的總和。

### 2. 單點更新 $A[k]$ (Update)

當我們修改 $A[k]$ 的值時，所有**覆蓋**了 $A[k]$ 的 $T[i]$ 區間和都需要被更新。

**步驟:**
1.  從 $k$ 開始，將變動量 $\Delta$ 加到 $T[k]$。
2.  更新 $k$ 到下一個**會覆蓋到 $k$ 的更大區間**的索引： $k = k + \text{lowbit}(k)$。
3.  重複此過程直到 $k$ 超出陣列範圍。

**範例：更新 $A[3]$**
* $T[3]$ 覆蓋 $A[3]$ (長度 1)。
* 下一個 $k$ 是 $3 + \text{lowbit}(3) = 3 + 1 = 4$。
* $T[4]$ 覆蓋 $A[1 \dots 4]$ (長度 4)，它也覆蓋了 $A[3]$。
* 下一個 $k$ 是 $4 + \text{lowbit}(4) = 4 + 4 = 8$。
* $T[8]$ 覆蓋 $A[1 \dots 8]$ (長度 8)，它也覆蓋了 $A[3]$。

你會發現，更新路徑是 $3 \rightarrow 4 \rightarrow 8 \rightarrow 16 \rightarrow \dots$。這條路徑的長度最多只有 $\log n$ 個節點，所以更新操作的時間複雜度是 $O(\log n)$。

---

### 💡 總結

Fenwick Tree 之所以高效，是因為它用 $\log n$ 個區間和，就能拼湊出任何長度的前綴和。同時，對 $A$ 中任何一個元素的修改，也只需要更新 $\log n$ 個 $T$ 陣列中的區間和。

---

# (4) Suffix tree / Suffix trie

## 🌳 一、 後綴樹/後綴字典樹的目的

它們的設計目的只有一個：將一個字串 $S$ 的**所有後綴 (Suffixes)** 組織起來，形成一個特殊的樹狀結構，從而實現：

1.  **極速的子字串查詢:** 快速判斷任意給定的模式 $P$ 是否是 $S$ 的子字串。
2.  **模式匹配的優化:** 快速找到所有出現 $P$ 的位置。

### 核心概念：什麼是後綴？

對於一個字串 $S = \text{"BANANA"}$：

* 後綴 1: $\text{"BANANA"}$
* 後綴 2: $\text{"ANANA"}$
* 後綴 3: $\text{"NANA"}$
* 後綴 4: $\text{"ANA"}$
* 後綴 5: $\text{"NA"}$
* 後綴 6: $\text{"A"}$

後綴樹就是將這 6 個字串全部插入到一棵樹中。為了讓每個後綴都有一個清晰的「結尾」，我們通常會在字串末尾加上一個**特殊的終止符號**（例如 $\$$）。

## 🌲 二、 後綴字典樹 (Suffix Trie)

在理解後綴樹之前，我們先看一個更簡單的概念：**後綴字典樹 (Suffix Trie)**。它就是一個標準的**字典樹 (Trie)**，但我們將所有後綴都插入其中。

### 構造過程範例： $S = \text{"ABA"}\$$

1.  **後綴:** "ABA"$、"BA"$、"A"$、""$。
2.  **插入:** 將這四個後綴依次插入到一個普通的字典樹中。



#### 🔹 Suffix Trie 的問題

雖然 Suffix Trie 可以工作，但它有一個嚴重的缺點：

* 如果字串 $S$ 的長度是 $N$，那麼它的後綴總長度大約是 $O(N^2)$。
* 對於長度為 $N$ 的字串，這個字典樹會有很多節點，佔用**巨大的記憶體**。

## 🌳 三、 後綴樹 (Suffix Tree)：優化 Suffix Trie

後綴樹就是為了解決 Suffix Trie 的**空間浪費**問題而誕生的。

### 核心優化：邊壓縮 (Edge Compression)

後綴樹的核心思想是將 Suffix Trie 中所有**只有一個子節點的路徑**（稱為**鏈 (Chains)**）壓縮成一條邊。

**不再是每個字母一個節點，而是將多個字母儲存在一條邊上。**

#### 範例： $S = \text{"BANANA"}\$$

1.  在 Suffix Trie 中，從根節點到 $\text{"BANANA"}\$$ 的路徑有 6 個節點。
2.  在 Suffix Tree 中，如果這條路徑上沒有分岔，它會被**壓縮成一條邊**，邊上標記著 $\text{"BANANA"}\$$。
3.  樹中的每條邊只儲存**子字串的起始索引和結束索引**，而不是實際的字串本身，這大大節省了空間。



#### 🔹 後綴樹的優勢

* **空間複雜度:** 節點數量不會超過 $O(N)$（$N$ 是字串長度）。空間大大優化！
* **查詢時間:** 可以在 $O(|P|)$ 的時間內完成對任意模式 $P$ 的搜尋，這是極快的。

---

## 應用：它能做什麼？

後綴樹可以高效解決以下問題：

1.  **子字串查詢 (Substring Search):** 查詢 $S$ 是否包含子字串 $P$。
2.  **最長重複子字串 (Longest Repeated Substring):** 找到 $S$ 中出現至少兩次的最長子字串。
3.  **最長公共子字串 (Longest Common Substring):** 找到兩個字串 $S_1$ 和 $S_2$ 中最長的公共子字串（這需要構造一個更複雜的**廣義後綴樹**）。
4.  **生物信息學:** 用於 DNA 或 RNA 序列的比對、基因組組裝等。

結論：**後綴樹是一種優化過的字典樹，它能夠以極快的速度解決涉及字串所有後綴的問題。**

示意圖:
https://www.researchgate.net/profile/Panos-Kalnis/publication/51942252/figure/fig1/AS:647927278080011@1531489309846/Suffix-tree-for-S-banana-denotes-endof-string-Edge-labels-on-a-path-from-the-root.png

---

# (5) KD-tree

參考資料:https://blog.yucheng.me/post/kd-tree/

---

# (6) Quad Tree (四元樹)

* 設計目的: 專門將二維 (2D) 平面分割成四塊相等象限，像 Google Maps 會一直放大把地圖切細。
* 新手理解: 每次將一張地圖切成四份（左上、右上、左下、右下）。如果某一區塊的資料點過多，就繼續切分。
* 應用: 地理資訊系統 (GIS)、影像壓縮、碰撞偵測（遊戲）。

---

# (7) Octree (八元樹) 

* 設計目的: 將三維 (3D) 空間分割成八塊相等體積的象限（八分之一）。
* 應用: 3D 圖形渲染、空間索引、空間分割。

參考網站：https://blog.csdn.net/weixin_43945471/article/details/132980886   
示意圖：https://i-blog.csdnimg.cn/blog_migrate/238388f4b5b9dc4e225fdf7659710546.png

---

# (8) Heap Tree (堆積樹)

* 設計目的: 是一種完全二元樹，用於快速找到和提取最大（或最小）的元素。
* 新手理解: 它不是用來搜尋的，而是用來排序優先權的。它保證父節點永遠大於或等於（最大堆）或小於或等於（最小堆）其所有子節點。
* 應用: 實現優先佇列 (Priority Queue)、堆排序 (Heapsort)。

示意圖：https://ithelp.ithome.com.tw/upload/images/20210929/201410515Dkjh2z8PX.png

---

# (9) Treap (Tree + Heap)

* 設計目的: 結合了二元搜尋樹 (BST) 和堆積 (Heap) 的特性，來確保樹的平衡。
* 新手理解: 每個節點有兩個值：鍵值 (Key)（用於 BST 排序）和優先權 (Priority)（用於 Heap 排序，隨機賦予）。透過隨機分配的優先權，Treap 能夠在操作過程中保持平均平衡。
* 優化點: 避免了像普通 BST 在最壞情況下退化成鏈表的問題。

---

## Tree Key (鍵值) vs Heap Key (優先權)

1.  **Tree Key (鍵值):** 維持**水平**順序（左邊小，右邊大）。
2.  **Heap Key (優先權):** 維持**垂直**順序（父節點高，子節點低）。

## 🔥 Heap Key (優先權) 的詳細解釋

在 Treap 中，我們稱 **Heap Key** 為**優先權 (Priority)**，它是一個**隨機**賦予的數值，是 Treap 能保持平衡的秘密武器。

### 1. 優先權的本質：隨機賦予的數值

當您將一個新的節點插入 Treap 時：

* **Tree Key (鍵值):** 由您要儲存的**資料本身**決定（例如，學生的 ID 或分數）。
* **Heap Key (優先權):** 由程式**隨機產生**一個大整數（例如，用亂數函式生成）。

**重要概念：** 優先權和鍵值之間**沒有任何關係**。

### 2. 優先權的功能：決定節點的「高度」

優先權的作用是強制樹滿足**最大堆 (Max Heap) 屬性**（通常是使用最大堆）：

* **規則：** 任何節點的**優先權**必須**大於或等於**其所有子節點的優先權。
* **影響：** 這迫使優先權越高的節點，在樹中越接近**根節點 (Root)**；優先權越低的節點，則會被推到越深的層次。

#### 💡 隨機平衡的原理

想像您有一個陣列 $[A, B, C, D]$：

1.  **如果只用鍵值 (BST):** 如果 $A < B < C < D$，樹會變成一條鏈表。
2.  **加入隨機優先權 (Treap):**
    * 假設 $A$ 的優先權 $P_A=80$ (高)。
    * $B$ 的優先權 $P_B=20$ (低)。
    * $C$ 的優先權 $P_C=95$ (很高)。

儘管 $A$ 的鍵值小於 $C$，但因為 $C$ 的**優先權最高** ($P_C=95$)，它會被旋轉到**根節點**的位置。這就像在建造一棟房子時，您隨機決定哪塊磚頭必須放在頂端。這種隨機性使得樹的形狀**平均高度保持在 $O(\log N)$**，從而實現了平衡。

### 3. 如何維護優先權：樹旋轉 (Rotation)

當新節點 $X$ 插入後，如果它破壞了**堆積屬性**（即 $X$ 的優先權 $P_X$ 比它的父節點 $P_{Parent}$ 高），我們必須使用**樹旋轉 (Tree Rotation)** 來修復它。

**樹旋轉**是 Treap 最關鍵的步驟，它可以在**不破壞 BST 屬性**的前提下，調整節點的父子關係。

#### 範例：違反堆積屬性

1.  **初始狀態:**
    * 父節點 (鍵值 $K_P$, 優先權 $P_P=50$)
    * 新節點 (鍵值 $K_X$, 優先權 $P_X=80$)

2.  **問題:** 假設 $K_X$ 按照 BST 規則被插入到 $K_P$ 的右子節點。此時 $P_X (80) > P_P (50)$，**違反了堆積規則**。

3.  **解決方法：左旋轉 (Left Rotation):**
    * 程式會進行一次**左旋轉**。
    * 結果是 $X$ 成為新的父節點 (向上移動)， $P$ 成為 $X$ 的左子節點 (向下移動)。
    * 現在 $X$ 在 $P$ 上面，滿足了 $P_X > P_P$ 的優先權規則。

---

## 🔑 總結：兩種鑰匙，兩種秩序

| 類型 | 樹鍵 (Tree Key) | 堆鍵 (Heap Key) - 優先權 |
| :--- | :--- | :--- |
| **數值來源** | 實際資料的值 (固定) | **隨機**產生 (不固定) |
| **遵循規則** | **BST 屬性** | **Heap 屬性** |
| **決定順序** | 決定**水平**順序 (左 $\lt$ 父 $\lt$ 右) | 決定**垂直**順序 (父優先權 $\ge$ 子優先權) |
| **最終目的** | 讓您能**找到**資料 (搜尋) | 讓樹保持**平衡** (旋轉) |

因此，Treap 的每個節點都是**一個結構體 (Struct)**，裡面同時包含這兩個值。當進行操作時，**鍵值**讓我知道去哪裡找，而**優先權**讓我知道是否需要進行旋轉來平衡樹。

![image](https://github.com/Thomas-debuger/11401_CS203A/blob/main/notes/Picture/left_rotation.jpg)

---

# (10) Splay Tree (伸展樹)

* 設計目的：一種自我調整 (Self-adjusting) 的二元搜尋樹。
* 新手理解：它的設計哲學是：您剛剛存取的節點，您很可能馬上又要存取它。每次存取一個節點後，它會執行一系列旋轉操作，將這個被存取的節點移動到樹的根部。「被查詢的 node 會被調到樹根」。
* 優化點：雖然單次操作的最壞情況可能很慢，但在一系列操作的攤還分析 (Amortized Analysis) 中，它的性能非常優異。
* 應用：緩存 (Caches) 和記憶體管理。
* 定義：在伸展樹上的一般操作都基於伸展操作。假設想要對一個二元搜尋樹執行一系列的尋找操作，為了使整個尋找時間更小，被查頻率高的那些條目就應當經常處於靠近樹根的位置。於是想到設計一個簡單方法，在每次尋找之後對樹進行調整，把被尋找的條目搬移到離樹根近一些的地方。伸展樹應運而生。伸展樹是一種自調整形式的二元搜尋樹，它會沿著從某個節點到樹根之間的路徑，通過一系列的旋轉把這個節點搬移到樹根去。

---

# p.17-p.21 BFT, DFT

1.  **BFT:** **廣度優先遍歷 (Breadth-First Traversal)**，或稱為 **廣度優先搜尋 (BFS)**。
2.  **DFT:** **深度優先遍歷 (Depth-First Traversal)**，或稱為 **深度優先搜尋 (DFS)**。

雖然它們的名稱不同，但它們都是用來系統性地訪問圖或樹中**所有節點**的方法。

---

## 🔍 核心差異：訪問的順序

BFT 和 DFT 的最主要區別在於它們**探索節點的順序**：

* **BFT (廣度優先):** **一層一層**地橫向探索。先訪問完當前節點的**所有鄰居**，然後才深入到下一層。
    * **像水波一樣擴散**。
* **DFT (深度優先):** **一條路走到底**地縱向探索。從當前節點開始，選擇一條路徑深入到底，然後再回溯 (Backtrack) 探索其他路徑。
    * **像迷宮探索者**。

---

## 🌊 一、 廣度優先遍歷 (BFT / BFS)

### 1. 邏輯與順序

BFS 從起始節點開始，先訪問所有距離為 1 的節點，再訪問所有距離為 2 的節點，依此類推。

**順序:** 根節點 $\rightarrow$ 第一層所有節點 $\rightarrow$ 第二層所有節點 $\rightarrow \dots$

### 2. 實現方式

* **使用資料結構:** **佇列 (Queue)**。
* **步驟:**
    1.  將起始節點放入**佇列**。
    2.  從佇列中取出節點 $V$。
    3.  訪問節點 $V$。
    4.  將 $V$ 所有**未訪問過**的鄰居節點依序放入佇列的**尾部**。
    5.  重複步驟 2-4，直到佇列為空。



### 3. 應用場景

* **最短路徑:** 在**無權重圖**中尋找最短路徑（因為它保證先找到距離最短的節點）。
* **網路爬蟲:** 從一個網頁開始，先爬取所有連結的網頁（第一層），再爬取這些網頁的連結（第二層）。
* **樹的層次遍歷:** 處理樹結構時，按層次訪問所有節點。

---

## 🌲 二、 深度優先遍歷 (DFT / DFS)

### 1. 邏輯與順序

DFS 從起始節點開始，盡可能地向深處探索。當到達一個沒有未訪問鄰居的節點時，它會**回溯**到上一個節點，嘗試另一條路徑。

**順序:** 根節點 $\rightarrow$ 一條路徑走到最深 $\rightarrow$ 回溯 $\rightarrow$ 探索另一條路徑。

### 2. 實現方式

* **使用資料結構:** **堆疊 (Stack)** 或**遞迴 (Recursion)**（遞迴底層也是使用函式呼叫堆疊）。
* **步驟 (遞迴):**
    1.  訪問當前節點 $V$。
    2.  對 $V$ 的**每一個未訪問過**的鄰居節點 $W$，**遞迴**地呼叫 DFS 函式。
    3.  當所有鄰居都訪問完畢，回溯到父節點。

### 3. 應用場景

* **拓撲排序 (Topological Sorting):** 對有向無環圖 (DAG) 進行排序。
* **尋找連通分量:** 檢查圖是否連通，或找出圖中的所有連通子圖。
* **迷宮求解:** 探索迷宮的一條路徑直到死胡同，然後回溯嘗試其他路徑。
* **樹的先序、中序、後序遍歷:** 這是 DFS 在樹上的三種具體實現方式。

### 4. 實作

* Preorder：根->左子節->右子節
* Inorder：左子節->根->右子節
* Postorder：左子節->右子節->根

---

## 總結比較

| 特性 | BFT (廣度優先) | DFT (深度優先) |
| :--- | :--- | :--- |
| **探索策略** | 橫向、一層一層 | 縱向、一條路走到底 |
| **主要工具** | **佇列 (Queue)** | **堆疊 (Stack) 或 遞迴 (Recursion)** |
| **優勢** | 尋找**最短路徑** | 容易實現，尋找所有**路徑**和**連通分量** |
| **缺點** | 記憶體消耗可能較大 (需要儲存所有未處理的同層節點) | 在某些圖中可能會陷入**無限循環**或走得太深 |

---

# p.22-p.31 Representation of Tree

Root: A   
Subtree root: B, C, D   
String representation: (A (B, C, D)) → (Root (Child node in sibling order separated by commas) )   
B → (B (E, F)); E (K, L) → (B (E (K, L), F))   
C → (C (G))   
D → (D (H, I, J) ); H (M) → (D ( H (M), I, J))   
A → (A (B, C, D)) → (A (B (E (K, L), F), C (G), D ( H (M), I, J))   

示意圖：![image](https://github.com/Thomas-debuger/11401_CS203A/blob/main/notes/Picture/representation%20of%20tree.png)

---

# p.34

# (1) AVL

**AVL 樹**（或稱 **Adelson-Velsky and Landis 樹**，以其發明者命名）是一種特殊的**自平衡二元搜尋樹 (Self-Balancing Binary Search Tree, BST)**。

它被設計來解決一般二元搜尋樹在最壞情況下可能退化成鏈表，導致搜尋效率降到 $O(n)$ 的問題。AVL 樹透過嚴格的平衡規則，確保樹的高度永遠保持在最小的 $O(\log n)$ 級別。

### 核心特性：平衡因子 (Balance Factor)

AVL 樹的核心規則非常嚴格：

1.  **二元搜尋樹 (BST) 特性：** 樹中任一節點，其左子樹中的所有節點值都小於它，右子樹中的所有節點值都大於它。
2.  **平衡規則 (The AVL Property)：** 對於樹中的**任意一個節點**，它的左子樹高度與右子樹高度的**差值絕對值不能超過 1**。
    * 這個高度差值被稱為**平衡因子 (Balance Factor)**。
    * 平衡因子只能是 $1$、 $0$ 或 $-1$。
    * 如果任一節點的平衡因子變成 $2$ 或 $-2$，樹就會進行**旋轉 (Rotation)** 操作來重新平衡。

### 如何維持平衡？

當向 AVL 樹中插入或刪除一個節點，導致某個節點的平衡因子被破壞（變成 $2$ 或 $-2$）時，AVL 樹會自動執行四種基本旋轉操作之一來重新平衡樹結構：

1.  **左旋 (Left Rotation)**
2.  **右旋 (Right Rotation)**
3.  **左右旋 (Left-Right Rotation)**
4.  **右左旋 (Right-Left Rotation)**

這些旋轉操作能夠在 $O(1)$ 的時間內完成，將樹調整回滿足 AVL 規則的狀態。

### 主要優勢

由於 AVL 樹的平衡條件極為嚴格，它保證了樹的高度始終是 $\log n$ 級別，因此：

| 操作 | 時間複雜度 | 說明 |
| :--- | :--- | :--- |
| 搜尋 (Lookup) | $O(\log n)$ | **優勢：** 這是 AVL 樹最強的優勢，它提供了**最快**的查找保證。 |
| 插入 (Insertion) | $O(\log n)$ | 包含插入節點本身和最多一次或兩次旋轉操作。 |
| 刪除 (Deletion) | $O(\log n)$ | 包含刪除節點本身和最多 $O(\log n)$ 次旋轉操作。 |

**總結來說，AVL 樹是所有平衡二元搜尋樹中，在「查詢效率」上表現最好的，但它的平衡調整（旋轉）次數可能會比紅黑樹多一些。**

---

# (2) Red-Black Tree

**紅黑樹 (Red-Black Tree, RBT)** 是一種設計巧妙的**自平衡二元搜尋樹 (Self-Balancing Binary Search Tree, BST)**。

它與 AVL 樹的目標相同：確保樹的高度始終保持在 $O(\log n)$，從而保證搜尋、插入和刪除操作的高效率。然而，紅黑樹的平衡策略比 AVL 樹更為「寬鬆」，它不是透過嚴格的高度差約束，而是透過為節點賦予「顏色」來實現平衡。

### 核心特性：顏色約束

紅黑樹的每個節點都會被標記為**紅色 (Red)** 或**黑色 (Black)**，並且必須遵守以下五個**顏色約束規則 (Color Constraints)**：

1.  **節點是紅或黑：** 每個節點不是紅色，就是黑色。
2.  **根節點是黑色：** 樹的根節點必須是黑色。
3.  **葉節點是黑色：** 所有外部葉節點（NIL 節點，代表空）都是黑色。
4.  **紅色節點限制：** 如果一個節點是紅色的，那麼它的子節點（如果有）**必須是黑色**（即：不允許兩個相鄰的紅色節點）。
5.  **黑高一致性：** 從**任一節點**到其所有後代**葉節點**的簡單路徑上，所包含的**黑色節點數量必須相同**。這個數量稱為該節點的「黑高 (Black Height)」。

### 平衡原理

遵守了這些規則，尤其是第 4 條（紅色節點限制）和第 5 條（黑高一致性），可以保證樹的最長路徑（從根到葉）不會超過最短路徑的兩倍。

* 最短路徑：全部是黑色節點。
* 最長路徑：黑紅交替，最多 $2 \times (\text{黑高})$ 個節點。

由於最長路徑和最短路徑長度相差不大，所以樹的高度始終被限制在 $\log n$ 的範圍內，從而達到平衡。

### 紅黑樹 vs. AVL 樹

| 特點 | 紅黑樹 (Red-Black Tree) | AVL 樹 (AVL Tree) |
| :--- | :--- | :--- |
| **平衡規則** | 顏色約束 (較寬鬆) | 高度差 $\leq 1$ (較嚴格) |
| **搜尋效率** | $O(\log n)$ | $O(\log n)$ **(更快)** |
| **插入/刪除成本** | 旋轉和重新著色**次數較少** | 旋轉**次數可能較多**，平衡調整較頻繁 |
| **實際應用** | **C++ STL map/set**、**Linux 核心**、Java TreeMap/TreeSet | 適合**查詢密集型**的應用 |

**總結：** 紅黑樹在插入和刪除操作後，維持平衡所需的**總體操作（旋轉 + 重新著色）次數少於 AVL 樹**，因此在需要大量插入和刪除操作的場合（例如作為記憶體中的通用資料結構），**紅黑樹的綜合性能通常更勝一籌**。這也是為什麼它被廣泛用於標準程式庫和作業系統核心中。

---

# (3) B-Tree / B+Tree

B-Tree（B 樹）和 B+Tree（B+ 樹）是專門為**外部儲存系統**（例如硬碟或 SSD）設計的自平衡樹狀資料結構，是現代**資料庫索引**和**檔案系統**的基礎。

它們與 AVL 樹和紅黑樹等二元樹最大的區別在於：它們是**多路查找樹 (Multi-way Search Tree)**，每個節點可以有**多個**子節點，這使得樹的結構更「矮」更「胖」。

### 核心設計理念：優化磁碟 I/O

在電腦中，從硬碟讀取資料（稱為 **I/O 操作**）比從記憶體讀取資料慢上萬倍。這些樹的設計目標就是：**在一次磁碟 I/O 中盡可能讀取更多的索引資訊，從而減少 I/O 次數。**

* **多鍵值節點 (Multi-key Node):** 每個節點會儲存多個鍵值 (Key) 和多個指向子節點的指針。
* **樹高極低:** 由於每個節點的分支多，即使資料量龐大，樹的高度也極低（通常只有 2 到 4 層），這意味著查找任何一筆資料都只需要極少的幾次磁碟 I/O。

---

## 🌳 B-Tree (B 樹)

B-Tree 的關鍵特點是**資料和索引都存在於樹中的所有節點**。

### 特性
1.  **資料分散在全樹：** 實際的資料記錄（或指向資料的指針）可以儲存在**根節點、內部節點**和**葉節點**。
2.  **查找：** 查找有可能在非葉節點就結束。



### 應用
* **MongoDB** 和 **Oracle** 等一些資料庫系統的索引。
* 通常作為理論基礎，但在實際應用中，B+Tree 更為常見。

---

## 🌲 B+Tree (B+ 樹)

B+Tree 是 B-Tree 的一種**優化**和**改良**，使其更適合資料庫索引和範圍查詢。

### 相對於 B-Tree 的主要區別
B+Tree 主要有三個關鍵的優化點：

1.  **內部節點只存索引 (Key Only):** 只有**葉節點**才儲存實際的資料記錄或指向資料的指針（非葉節點只儲存索引鍵值）。
    * **優勢:** 內部節點變得更小，在一個磁碟塊中能儲存更多的索引鍵值，進一步**降低樹的高度**，減少 I/O 次數。
2.  **所有資料在葉節點：** 所有的資料記錄都集中在葉節點層，並且葉節點是按鍵值排序的。
    * **優勢:** 所有查詢（不論成功與否）都必須從根走到葉節點，因此**查詢效率穩定**且一致。
3.  **葉節點鏈接 (Linked Leaves):** 所有葉節點之間都使用**鏈結串列 (Linked List)** 串接起來。
    * **優勢:** 這使得**範圍查詢 (Range Query)** 變得極其高效。一旦找到範圍的起始點，就可以直接沿著鏈結串列快速遍歷所有連續的資料，而不需要再回到父節點進行樹的中序遍歷。



### 應用
* **MySQL (InnoDB 儲存引擎)**、**PostgreSQL** 等絕大多數關聯式資料庫的**主要索引結構**。
* **檔案系統 (File Systems)**，例如 NTFS, ext4 等，也廣泛使用 B+Tree。

### 總結比較

| 特性 | B-Tree (B 樹) | B+Tree (B+ 樹) |
| :--- | :--- | :--- |
| **資料存放位置** | 根節點、內部節點、葉節點 **都**可以存資料 | **只**在**葉節點**存資料 |
| **內部節點** | 存索引鍵值 **和** 資料 | **只**存索引鍵值 |
| **範圍查詢** | 效率較低，需進行中序遍歷 | **高效**，透過葉節點鏈結串列進行線性掃描 |
| **查詢穩定性** | 較不穩定（資料可能在不同層被找到） | **穩定**（每次查詢都必須到達葉節點） |

鑑於 B+Tree 在資料庫中的卓越性能（尤其在範圍查詢和降低 I/O 方面），它是當今資料索引的**業界標準**。

---

# p.35 Summary

這是一個關於**樹狀資料結構 (Tree Data Structure)** 的**總結表**，它概括了樹結構中的幾個**核心概念**、它們的**目的**或**特性**，以及它們在平衡樹中的**時間複雜度**。

### 🌳 總結表的內容解讀

| 概念 (Concept) | 目的/特性 (Purpose) | 時間複雜度 (Complexity) | 備註 |
| :--- | :--- | :--- | :--- |
| **平衡樹 (Balanced Tree)** | **維持對數級別的高度**，以確保**高效率** (Maintain log-scale height for efficiency) | 搜尋/插入：$O(\log n)$ | 這是最重要的目標，例如 AVL 樹、紅黑樹和 B 樹就是為此而生。它確保了隨著資料量 $n$ 增加，操作時間只會緩慢增長。 |
| **遍歷 (DFT)** <br> *(Depth-First Traversal)* | **遞迴的訪問順序** (Recursive visiting order) | $O(n)$ | **深度優先遍歷**。它有三種主要形式：前序、中序、後序。時間複雜度是 $O(n)$，因為每個節點都會被訪問一次。  |
| **遍歷 (BFT)** <br> *(Breadth-First Traversal)* | **層次順序的訪問** (Level-order visiting) | $O(n)$ | **廣度優先遍歷**（通常使用佇列 Queue 實現）。時間複雜度是 $O(n)$，因為同樣需要訪問每個節點一次。  |
| **應用 (Application)** | 決策樹、二元搜尋樹 (BST)、B-樹、紅黑樹等 (Decision Tree, BST, B-Tree, Red-Black, etc.) | — | 樹狀結構在電腦科學中的實際應用非常廣泛。 |

### 🔍 重點解析

#### **1\. 平衡 (Balance) 與效率**

這個表格強調了「平衡」的重要性。對於一個 $n$ 個節點的樹，如果它是平衡的，那麼對任何節點的搜尋或操作都只需要訪問約 $\log_2 n$ 個節點。

  * 例如，一個有 100 萬個節點的樹 ($\approx 2^{20}$)，如果是平衡的，最多只需約 **20 次**操作。
  * 如果樹退化成一條鏈，則可能需要 **100 萬次**操作。

因此，**$O(\log n)$ 的複雜度是平衡樹的價值所在。**

#### **2\. 遍歷 (Traversal)**

遍歷是訪問樹中所有節點的方法。無論是深度優先還是廣度優先，都需要訪問所有 $n$ 個節點，所以時間複雜度都是**線性**的 $O(n)$。

---

# p.36 ADT

這份資料是**抽象資料型態 (Abstract Data Type, ADT)** 中 **二元樹 (Binary Tree)** 的**正式定義**。

它定義了二元樹這種資料結構的**邏輯模型**和可以對其進行的**操作 (Functions)**，但沒有說明這些操作在底層程式碼中是如何實現的（這是 ADT 的核心特徵）。

以下是對這個 ADT 定義的詳細解釋：

---

### 📘 ADT: 二元樹 (Binary Tree)

### 1. 結構與對象 (Objects)

* **定義：** 二元樹是**節點的有限集合**。
* **兩種狀態：**
    * **空 (Empty):** 集合為空。
    * **非空：** 包含一個**根節點 (Root Node)**、一個**左子二元樹 (left BinaryTree)**，以及一個**右子二元樹 (right BinaryTree)**。
    > 📝 **這是一個典型的遞迴定義。** 任何非空的二元樹都是由一個根節點和兩個（可能是空的）子樹構成的。



### 2. 函數與操作 (Functions)

這些函數是外部使用者與二元樹這個資料結構互動的**唯一介面**：

| 函數名稱 | 傳入參數 (Input) | 傳出結果 (Output) | 目的/功能 |
| :--- | :--- | :--- | :--- |
| `Create()` | 無 | `BinaryTree` | **建立一個空的二元樹**。 |
| `IsEmpty(bt)` | `BinaryTree` (bt) | `Boolean` (TRUE/FALSE) | **檢查**給定的二元樹是否為**空**。 |
| `MakeBT(bt1, item, bt2)` | 兩個 `BinaryTree` (bt1, bt2), 一個資料元素 (`item`) | `BinaryTree` | **建立新的二元樹**：以 `item` 為根節點資料，`bt1` 為左子樹，`bt2` 為右子樹。這是組合樹結構的主要方法。 |
| `Lchild(bt)` | `BinaryTree` (bt) | `BinaryTree` | **回傳**給定二元樹的**左子樹**。如果樹是空的則報錯。 |
| `Rchild(bt)` | `BinaryTree` (bt) | `BinaryTree` | **回傳**給定二元樹的**右子樹**。如果樹是空的則報錯。 |
| `Data(bt)` | `BinaryTree` (bt) | `element` (資料元素) | **回傳**給定二元樹**根節點中儲存的資料**。如果樹是空的則報錯。 |

### 🎯 總結：ADT 的意義

這個 ADT 定義的重點是：

1.  **分離介面與實現：** 告訴使用者「可以對二元樹做什麼」（操作列表），但不告訴使用者「如何做到」（底層是陣列、指標、還是其他結構）。
2.  **遞迴基礎：** 二元樹是透過**遞迴**的方式定義的 (`MakeBT`、`Lchild`、`Rchild` 都操作 `BinaryTree` 物件)。

這個定義是所有基於二元樹的演算法（如遍歷、搜尋、插入）的抽象基礎。
