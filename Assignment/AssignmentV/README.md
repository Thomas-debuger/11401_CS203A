這份作業是 **Assignment V — Tree**，由學生魏允鴻（1131417）完成 。這是一份深度探討「**樹狀資料結構（Tree Structures）**」的綜合性報告，重點在於從理論定義、結構轉化到實際的視覺化構建，內容包含：

---

### **1. 樹狀結構的深度定義與特性**

作業詳細定義了八種常見的樹狀變體，並區分其結構約束與應用場景：

* 
**基礎結構**：包含**一般樹（General Tree）**與**二元樹（Binary Tree）**，定義了父子節點的基本階層關係 。


* **形狀與排序約束**：
* 
**完全二元樹（Complete Binary Tree）**：強調節點由左至右填滿，適合陣列儲存 。


* 
**二元搜尋樹（BST）**：加入「左小右大」的排序性質，支援中序遍歷輸出遞增序列 。




* **自我平衡機制**：
* 
**AVL Tree**：嚴格限制左右子樹高度差不超過 1，確保搜尋效能穩定在  。


* 
**紅黑樹（Red-Black Tree）**：透過節點顏色（紅/黑）規則與旋轉，在插入/刪除頻繁的情境下提供更穩定的效能 。




* 
**堆積結構**：介紹了 **Max Heap** 與 **Min Heap**，分別用於快速取得最大值與最小值，是實作優先權佇列的核心 。



---

### **2. 家族演化與結構轉化分析**

作業透過階層圖（Hierarchy Diagram）說明了不同樹之間是如何透過「增加約束」演化而來的：

* **演化路徑**：
1. 
**General Tree**  限制子節點數  **Binary Tree** 。


2. 
**Binary Tree**  加入排序規則  **BST**  加入平衡機制  **AVL / Red-Black Tree** 。


3. 
**Complete Binary Tree**  加入父子大小關係  **Max/Min Heap** 。





---

### **3. 實作構建與視覺化驗證**

針對一組給定的 20 個整數（37, 142, 5, ..., 160），作業展示了在不同規則下的構建過程 ：

* 
**BST 構建**：遵循左小右大規則，遞迴決定插入位置 。


* 
**平衡調整**：描述了 AVL 樹如何透過中序序列取中點遞迴構建，以及紅黑樹在插入時如何處理「雙紅（Red-Red）」衝突 。


* 
**堆積建立（Heapify）**：說明了從最後一個非葉節點開始，由下而上（Bottom-up）調整結構以符合堆積性質的過程 。



---

### **4. 實務應用與效能反思**

作業最後討論了不同場景下的最佳選擇：

* 
**搜尋導向（Search-heavy）**：推薦 **AVL 樹**，因其平衡最嚴格，查詢路徑最短 。


* 
**頻繁更新（Frequent Updates）**：推薦 **紅黑樹**，因其旋轉調整次數較少，效能較均衡 。


* 
**靜態資料搜尋**：推薦 **排序陣列 + 二分搜尋**，在無需更新的情境下最節省記憶體且實作簡單 。



---

**總結**：這是一份結合了理論研究與工具實作（Tree Visualizer）的作業，旨在訓練學生掌握樹狀結構在記憶體利用、搜尋效率與平衡維護之間的權衡。

您需要我針對作業中提到的「紅黑樹旋轉規則（LL/RR/LR/RL）」為您做更具體的步驟解說嗎？
